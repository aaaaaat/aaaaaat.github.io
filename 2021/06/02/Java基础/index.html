<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java基础 | 小胖的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2021/06/02/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="小胖的博客">
<meta property="og:description" content="附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/02/CFLQGe1HsE7Ppit.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/E5oHDMeuQiJNzZg.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/1waijkvbfJO7qhM.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/HEeCUAIZJtF9cmN.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/cIDKTHCXrtJMYfd.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/4odVRfM3hpYZSB2.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/U5JGET4xbBVvqkm.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/lgdUjSfQ5kJhuM1.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/Uqxrju2AfYhD1dE.png">
<meta property="og:image" content="https://i.loli.net/2021/06/02/yceQBYnWDJG3r1E.png">
<meta property="article:published_time" content="2021-06-02T05:54:29.000Z">
<meta property="article:modified_time" content="2021-06-02T13:46:51.810Z">
<meta property="article:author" content="PP">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="hashmap">
<meta property="article:tag" content="votile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/02/CFLQGe1HsE7Ppit.png">
  
    <link rel="alternate" href="/atom.xml" title="小胖的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小胖的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录备战秋招的点点滴滴</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">专栏</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T05:54:29.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程是程序的一次执行，是系统进行资源分配和调度的独立单位。</li>
</ul>
<p>​       作用：程序能够并发执行提高资源利用率和吞吐率</p>
<hr>
<p><strong>为什么用线程？</strong></p>
<p>1、由于进程是资源分配和调度的资本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多。</p>
<p>2、线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。</p>
<hr>
<ul>
<li>线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。</li>
</ul>
<h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><ul>
<li><p>java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong></p>
</li>
<li><p>使用synchronized之后，会在编译之后在<strong>同步的代码块前后加上monitorenter和monitorexit字节码指令</strong>，他依赖操作系统底层互斥锁实现（作用：实现原子性操作和解决共享变量的内存可见性问题）</p>
<p>1、执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。<strong>此时其他竞争锁的线程则会进入等待队列中。</strong></p>
<p>2、执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。</p>
</li>
<li><p><strong>synchronized是排它锁</strong>，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，</p>
<p>1、而且由于Java中的线程和操作系统原生线程是一一对应的，<strong>线程被阻塞或者唤醒时时会从用户态切换到内核态</strong>，这种转换非常消耗性能。</p>
<p>2、从内存语义来说，加锁的过程会<strong>清除工作内存中的共享变量（用户态</strong>），再<strong>从主内存读取（内核态）</strong>，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p>
</li>
<li><p>synchronized实际上有<strong>两个队列waitSet和entryList</strong>：<br>1、当多个线程进入同步代码块时，首先进入entryList</p>
<p>2、有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1</p>
<p>3、<strong>如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</strong></p>
<p>4、如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/02/CFLQGe1HsE7Ppit.png" alt="image-20210602093422755.png"></p>
<h1 id="锁的优化机制"><a href="#锁的优化机制" class="headerlink" title="锁的优化机制"></a>锁的优化机制</h1><p>从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<p>锁的状态从低到高依次为<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<hr>
<ul>
<li><p><strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。<strong>自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态</strong>，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。</p>
</li>
<li><p><strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，<strong>而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
</li>
<li><p><strong>锁粗化</strong>：锁粗化指的是<strong>有很多操作都是对同一个对象进行加锁</strong>，就会把<strong>锁的同步范围扩展到整个操作序列之外。</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>偏向锁</strong>：当线程访问同步块获取锁时，<strong>会在对象头和栈帧中的锁记录里存储偏向锁的线程ID</strong>，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，<strong>当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁</strong>。可以用过设置-XX:+UseBiasedLocking开启偏向锁。</p>
</li>
<li><p><strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，<strong>JVM将会使用CAS方式来尝试获取锁（发生竞争），如果更新成功则会把对象头中的状态位标记为轻量级锁</strong>，如果更新失败，当前线程就尝试自旋来获得锁。</p>
</li>
</ul>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<p><img src="https://i.loli.net/2021/06/02/E5oHDMeuQiJNzZg.png" alt="image-20210602093705252.png"></p>
<hr>
<p>为什么升级轻量级锁后，要在当前线程栈帧创建锁记录空间，并将Mark word复制到锁空间？</p>
<p>线程以轻量级锁(Fast Lock)的方式进入同步块时，先在当前的活动记录(Activation Record)，就是我们平时所说的栈帧中分配一个Lock Record，用以复制当前锁对象Object Header中的markWord——displaced_header；然后尝试使用CAS的方式将对象的mark完全替换为刚刚在栈上（On-Stack）中分配的Lock Record的指针（就是这个锁记录的地址）——刚好HotSpot VM会确保这个地址的后两位是清零的，就是“00”——所谓的轻量级锁的状态。</p>
<p>如果CAS失败了呢，“说明此时有其它线程获取了锁，此时markword应该指向其它线程的栈帧了”只涉及到了一种情况；与此同时<strong>还有一种情况就是可能线程以递归的方式再次去获得轻量级锁——说明线程之前已经获得锁了，活动记录中已经存在一个锁对象markword对应的Lock Record了，这个Lock Record显然与再次进入同步块时在栈帧中创建的锁记录不是同一个，CAS操作无遗会失败。在这种情况下，栈帧中的锁对象会被置零。——这就是为什么要再次判断线程是否获得锁的原因。</strong></p>
<h1 id="对象头具体包含哪些内容"><a href="#对象头具体包含哪些内容" class="headerlink" title="对象头具体包含哪些内容"></a>对象头具体包含哪些内容</h1><p>在我们常用的Hotspot虚拟机中，对象在内存中布局实际包含3个部分：</p>
<ol>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<p>而对象头包含两部分内容，<strong>Mark Word中的内容会随着锁标志位而发生变化</strong>，所以只说存储结构就好了。</p>
<ol>
<li>对象自身运行时所需的数据，也被称为Mark Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。</li>
<li>存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。</li>
</ol>
<p><em>如果是数组的话，则还包含了数组的长度</em></p>
<p><img src="https://i.loli.net/2021/06/02/1waijkvbfJO7qhM.png" alt="image-20210602095242045.png"></p>
<h1 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h1><p>相比于synchronized，<strong>ReentrantLock需要显式的获取锁和释放锁</strong>，相对现在基本都是用JDK7和JDK8的版本，ReentrantLock的效率和synchronized区别基本可以持平了。</p>
<hr>
<p>他们的主要区别有以下几点：</p>
<ol>
<li><strong>等待可中断</strong>，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。</li>
<li><strong>公平锁</strong>：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。</li>
<li><strong>绑定多个条件</strong>：ReentrantLock可以同时绑定多个Condition条件对象。</li>
</ol>
<p>ReentrantLock基于AQS(<strong>AbstractQueuedSynchronizer 抽象队列同步器</strong>)实现。</p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>AQS内部维护一个state状态位，尝试加锁的时候通过CAS(CompareAndSwap)修改值，<strong>如果成功设置为1，并且把当前线程ID赋值</strong>，则代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，<strong>释放锁的时候则会把state重新置为0，同时当前线程ID置为空。</strong></p>
<p><img src="https://i.loli.net/2021/06/02/HEeCUAIZJtF9cmN.png" alt="image-20210602100735320.png"></p>
<h1 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h1><p>CAS叫做CompareAndSwap，比较并交换，<strong>主要是通过处理器的指令来保证操作的原子性</strong>，它包含三个操作数：</p>
<ol>
<li>变量内存地址，V表示</li>
<li>旧的预期值，A表示</li>
<li>准备设置的新值，B表示</li>
</ol>
<p>当执行CAS指令时，<strong>只有当V等于A时</strong>，才会用B去更新V的值，否则就不会执行更新操作。</p>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><p>CAS的缺点主要有3点：</p>
<ul>
<li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。</li>
</ul>
<p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<ul>
<li><p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</p>
</li>
</ul>
<h1 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h1><p>HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是<strong>put插入数据的过程，get查询数据以及扩容的方式</strong>。<strong>JDK1.7和1.8的主要区别在于头插和尾插方式的修改</strong>，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。</p>
<hr>
<h2 id="put插入数据流程"><a href="#put插入数据流程" class="headerlink" title="put插入数据流程"></a>put插入数据流程</h2><p>1、往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&amp;hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。</p>
<p>2、找到数组中的位置之后，如果数组中没有元素直接存入</p>
<p>3、反之则判断key是否相同，key相同就覆盖</p>
<p>4、否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成红黑树</p>
<p><strong>5、最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。</strong></p>
<h2 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h2><p>一般如果<code>new HashMap()</code> 不传值，默认大小是 16，负载因子是 0.75， 如果自己<strong>传入初始大小 k，初始化大小为大于 k 的 2 的整数次方</strong>。</p>
<p>例如如果传 10，大小为 16（传入k=50，大小为2的6次方）。</p>
<p>算法就是让初始二进制分别右移 1，2，4，8，16位，与自己异或，把高位第一个为 1 的数通过不断右移，把高位为 1 的后面全变为 1，111111 + 1 = 1000000 = 2的6次方（符合大于 50 并且是 2 的整数次幂 ） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123; </span><br><span class="line">int n = cap - 1;  </span><br><span class="line">n |= n &gt;&gt;&gt; 1; </span><br><span class="line">n |= n &gt;&gt;&gt; 2; </span><br><span class="line">n |= n &gt;&gt;&gt; 4; </span><br><span class="line">n |= n &gt;&gt;&gt; 8;  </span><br><span class="line">n |= n &gt;&gt;&gt; 16; </span><br><span class="line">return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么-HashMap-的数组长度要取-2-的整数幂"><a href="#为什么-HashMap-的数组长度要取-2-的整数幂" class="headerlink" title="为什么 HashMap 的数组长度要取 2 的整数幂?"></a>为什么 HashMap 的数组长度要取 2 的整数幂?</h2><p>因为这样（数组长度 -1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10100101 11000100 00100101</span><br><span class="line">&amp; 00000000 00000000 00001111</span><br><span class="line">----------------------------------  </span><br><span class="line">  00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-是线程安全的吗？"><a href="#HashMap-是线程安全的吗？" class="headerlink" title="HashMap 是线程安全的吗？"></a><strong>HashMap 是线程安全的吗？</strong></h2><p>不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有<strong>数据覆盖、多线程同时扩容</strong>的问题。</p>
<h2 id="那你平常怎么解决这个线程不安全的问题？"><a href="#那你平常怎么解决这个线程不安全的问题？" class="headerlink" title="那你平常怎么解决这个线程不安全的问题？"></a><strong>那你平常怎么解决这个线程不安全的问题？</strong></h2><p>Java 中有 <strong>HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap</strong> 可以实现线程安全的 Map。</p>
<ol>
<li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大；</li>
<li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li>
<li>ConcurrentHashMap 使用分段锁，降低了锁粒度，让并发度大大提高。</li>
</ol>
<h2 id="JDK1-8的优化"><a href="#JDK1-8的优化" class="headerlink" title="JDK1.8的优化"></a>JDK1.8的优化</h2><p>1、<strong>数组+链表改成了数组+链表或红黑树</strong>；</p>
<p>防止发生 hash 冲突，链表长度过长，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code>；</p>
<p>2、链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，<strong>1.8 遍历链表，将元素放置到链表的最后；</strong></p>
<p> A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环。</p>
<p>3、扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，<strong>1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小；</strong></p>
<p>这是由于扩容是扩大为原数组大小的 2 倍，用于计算数组位置的掩码仅仅只是高位多了一个 1，举个例子：</p>
<p>扩容前长度为 16，用于计算 <strong>(n-1) &amp; hash</strong> 的二进制 n - 1 为 0000 1111，</p>
<p>扩容后为 32 后的二进制就高位多了 1，———————–&gt;为 0001 1111。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>多线程环境可以使用</p>
<ul>
<li>Collections.synchronizedMap同步加锁的方式</li>
<li>还可以使用HashTable</li>
<li>但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li>
</ul>
<p>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</p>
<h3 id="1-7分段锁"><a href="#1-7分段锁" class="headerlink" title="1.7分段锁"></a><strong>1.7分段锁</strong></h3><p>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，<strong>Segment继承与ReentrantLock，Segment则包含HashEntry的数组</strong>，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p>
<p><strong>实际上就是相当于每个Segment都是一个HashMap</strong>，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p>
<p>1、成员变量使用 volatile 修饰，免除了指令重排序，同时保证内存可见性</p>
<p>2、另外使用 CAS 操作和 synchronized 结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p>
<h4 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a><strong>put流程</strong></h4><p>其实发现整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程我就简化了，因为和HashMap基本上是一样的。</p>
<ol>
<li>计算hash，定位到segment，segment如果是空就先初始化</li>
<li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li>
<li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样</li>
</ol>
<h3 id="1-8CAS-synchronized"><a href="#1-8CAS-synchronized" class="headerlink" title="1.8CAS+synchronized"></a><strong>1.8CAS+synchronized</strong></h3><p>1.8抛弃分段锁，转为用CAS+synchronized来实现，同样HashEntry改为Node，也加入了红黑树的实现。主要还是看put的流程。</p>
<h4 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a><strong>put流程</strong></h4><ol>
<li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li>
<li>如果当前数组位置是空则直接通过CAS自旋写入数据</li>
<li>如果hash==MOVED，说明需要扩容，执行扩容</li>
<li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/cIDKTHCXrtJMYfd.png" alt="image-20210602104739991.png"></p>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，他没有上下文切换的额外开销成本。</p>
<hr>
<p>使用volatile声明的变量，可以确保值被更新的时候对其他线程立刻可见。</p>
<ul>
<li><strong>volatile使用内存屏障来保证不会发生指令重排</strong>，解决了内存可见性的问题。</li>
</ul>
<p>我们知道，线程都是从主内存中读取共享变量到工作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可见性问题。</p>
<p>举个例子，假设现在我们是<strong>两级缓存的双核CPU架构，包含L1、L2两级缓存。</strong></p>
<ol>
<li><p>线程A首先获取变量X的值，由于最初两级缓存都是空，所以直接从主内存中读取X，假设X初始值为0，线程A读取之后把X值都修改为1，同时写回主内存。这时候缓存和主内存的情况如下图。</p>
<img src="https://i.loli.net/2021/06/02/4odVRfM3hpYZSB2.png" alt="image-20210602110335935.png" style="zoom: 33%;" /></li>
</ol>
<p> 线程B也同样读取变量X的值，由于L2缓存已经有缓存X=1，所以直接从L2缓存读取，之后线程B把X修改为2，同时写回L2和主内存。这时候的X值入下图所示。</p>
<p>那么线程A如果再想获取变量X的值，<strong>因为L1缓存已经有x=1了，所以这时候变量内存不可见问题就产生了，B修改为2的值对A来说没有感知。</strong></p>
<img src="https://i.loli.net/2021/06/02/U5JGET4xbBVvqkm.png" alt="image-20210602110515392.png" style="zoom:33%;" />

<p>那么，如果X变量用volatile修饰的话，当线程A再次读取变量X的话，<strong>CPU就会根据缓存一致性协议强制线程A重新从主内存加载最新的值到自己的工作内存，而不是直接用缓存中的值。</strong></p>
<h2 id="缓存一致性协议与volatile"><a href="#缓存一致性协议与volatile" class="headerlink" title="缓存一致性协议与volatile"></a>缓存一致性协议与volatile</h2><p>volatile是Java这种高级语言中的一个关键字，要实现这个volatile的功能，需要借助MESI！（<strong>请注意，这里只是说Java的volatile，而不涵盖C和C++的volatile</strong>）</p>
<p>CPU有缓存一致性协议：MESI，这不错。但MESI并非是无条件生效的！</p>
<p>不是说CPU支持MESI，那么你的变量就默认能做到缓存一致了。</p>
<p>根据MESI，CPU某核（假设CPU0）的缓存行（包含变量x）是M、S、或E的时候，如果总线嗅探到了变量x被其其他核（比如CPU1）执行了写操作（remote write）那么CPU0中的该缓存行会置为I（无效），在CPU0后续对该变量执行读操作的时候，发现是I状态，就会去主存中同步最新的值（其实由于L3缓存的存在，这里也可能是直接从L3同步到CPU0的L1和L2缓存，而不直接访问主存）</p>
<p>但实际可能不太理想，因为在CPU1执行写操作，要等到其他CPU（比如CPU0、CPU2……）将对应缓存行置为I状态，然后再将数据同步到主存，这个写操作才能完成。由于这样性能较差所以引入了Store Buffer，CPU1只需要将数据写入到Store Buffer，而不等待其他CPU把缓存行状态置为I，就开始忙别的去了。等到其他CPU通知CPU1我们都知道那个缓存失效啦，然后这个数据才同步到主存。</p>
<p>java虚拟机在实现volatile关键字的时候，是写入了一条lock 前缀的汇编指令。</p>
<p><strong>lock 前缀的汇编指令会强制写入主存，也可避免前后指令的CPU重排序，并及时让其他核中的相应缓存行失效，从而利用MESI达到符合预期的效果。</strong></p>
<p>非lock前缀的汇编指令在执行写操作的时候，可能是是不生效的。比如前面所说的Store Buffer的存在，lock前缀的指令在功能上可以等价于内存屏障，可以让其立即刷入主存。</p>
<p>再来介绍一下何谓lock前缀指令。lock指令在汇编中不是单独出现的，而是作为前缀来修饰其他指令的。可以和lock前缀修饰的指令有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG,DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock addl $0×0, (%esp)</span><br></pre></td></tr></table></figure>

<p>addl指令执行的时候会触发一个LOCK#信号，锁缓存(独占变量所在缓存行），指令执行完毕之后锁定解除。注意addl $0×0, (%esp)是一个空操作，不会有任何影响，这里只是为了配合触发lock的效果</p>
<p>是volatile的底层实现，满足了MESI的触发条件，才让变量有了缓存一致性。</p>
<h2 id="内存屏障的问题"><a href="#内存屏障的问题" class="headerlink" title="内存屏障的问题"></a>内存屏障的问题</h2><p>volatile修饰之后会加入不同的内存屏障来保证可见性的问题能正确执行。这里写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不一样，比如x86平台上，只有StoreLoad一种内存屏障。</p>
<ol>
<li>StoreStore屏障，保证上面的普通写不和volatile写发生重排序</li>
<li>StoreLoad屏障，保证volatile写与后面可能的volatile读写不发生重排序</li>
<li>LoadLoad屏障，禁止volatile读与后面的普通读重排序</li>
<li>LoadStore屏障，禁止volatile读和后面的普通写重排序</li>
</ol>
<img src="https://i.loli.net/2021/06/02/lgdUjSfQ5kJhuM1.png" alt="image-20210602111851692.png" style="zoom:33%;" />

<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加入了高速缓存，高速缓存一般可以分为L1、L2、L3三级缓存。基于上面的例子我们知道了这导致了缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU的重排序导致了原子性和有序性的问题，JMM内存模型正是对多线程操作下的一系列规范约束，因为不可能让陈雇员的代码去兼容所有的CPU，<strong>通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到一致的内存访问效果，同时也是保证在高效并发的时候程序能够正确执行。</strong></p>
<img src="https://i.loli.net/2021/06/02/Uqxrju2AfYhD1dE.png" alt="image-20210602112233460.png" style="zoom:33%;" />

<ul>
<li><p><strong>原子性</strong>：Java内存模型通过read、load、assign、use、store、write来保证原子性操作，此外还有lock和unlock，直接对应着synchronized关键字的monitorenter和monitorexit字节码指令。</p>
</li>
<li><p><strong>可见性</strong>：可见性的问题在上面的回答已经说过，Java保证可见性可以认为通过volatile、synchronized、final来实现。</p>
</li>
<li><p><strong>有序性</strong>：由于处理器和编译器的重排序导致的有序性问题，Java通过volatile、synchronized来保证。</p>
</li>
</ul>
<h4 id="volatile和synchronize的比较："><a href="#volatile和synchronize的比较：" class="headerlink" title="volatile和synchronize的比较："></a>volatile和synchronize的比较：</h4><p>1.volatile是线程同步的轻量级实现，所以volatile的性能要比synchronize好；<br>   volatile只能用于修饰变量，synchronize可以用于修饰方法、代码块。随着jdk技术的发展，synchronize在执行效率上会得到较大提升，所以synchronize在项目过程中还是较为常见的；</p>
<p>2.多线程访问volatile不会发生阻塞；而synchronize会发生阻塞；</p>
<p>3.volatile能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize可以保证变量原子性；</p>
<p>4.volatile是变量在多线程之间的可见性；synchronize是多线程之间访问资源的同步性；</p>
<p>对于volatile修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。</p>
<h4 id="happen-before规则"><a href="#happen-before规则" class="headerlink" title="happen-before规则"></a><strong>happen-before规则</strong></h4><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：</p>
<ol>
<li>单线程每个操作，happen-before于该线程中任意后续操作</li>
<li>volatile写happen-before与后续对这个变量的读</li>
<li>synchronized解锁happen-before后续对这个锁的加锁</li>
<li>final变量的写happen-before于final域对象的读，happen-before后续对final变量的读</li>
<li>传递性规则，A先于B，B先于C，那么A一定先于C发生</li>
</ol>
<h4 id="工作内存和主内存"><a href="#工作内存和主内存" class="headerlink" title="工作内存和主内存"></a>工作内存和主内存</h4><ul>
<li><p>主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。</p>
</li>
<li><p>而工作内存就是CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。</p>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><strong>什么是ThreadLocal变量</strong></p>
<p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。</li>
<li>既然每个 Thread 有自己的实例副本，<strong>且其它 Thread 不可访问</strong>，那就不存在多线程间共享的问题。</li>
</ul>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例<strong>且该实例需要在多个方法中被使用</strong>，也即变量在线程间隔离而在方法或类间共享的场景。</p>
<p><strong>ThreadLocal实现原理</strong></p>
<p>首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。</p>
<p>因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 set 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;   </span><br><span class="line">    Thread t = Thread.currentThread();   </span><br><span class="line">    ThreadLocalMap map = getMap(t);   </span><br><span class="line">    if (map != null)   </span><br><span class="line">        return (T)map.get(this);   </span><br><span class="line">  </span><br><span class="line">    // Maps are constructed lazily.  if the map for this thread   </span><br><span class="line">    // doesn&#x27;t exist, create it, with this ThreadLocal and its   </span><br><span class="line">    // initial value as its only entry.   </span><br><span class="line">    T value = initialValue();   </span><br><span class="line">    createMap(t, value);   </span><br><span class="line">    return value;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>createMap方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;   </span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap是个静态的内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;   </span><br><span class="line">........   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中</strong>，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p>
<h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a><strong>内存泄漏问题</strong></h2><p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉<strong>。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</strong></p>
<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，<strong>那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</strong></p>
<p>建议回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。 <strong>尽量在代理中使用try-finally块进行回收</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objectThreadLocal.set(userInfo); </span><br><span class="line">try &#123;</span><br><span class="line">    // ... </span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">    objectThreadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<p>如上文所述，ThreadLocal 适用于如下两种场景</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>对于第一点，每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。</p>
<p>对于第二点，可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅。</p>
<p>1）存储用户Session</p>
<p>一个简单的用ThreadLocal来存储Session的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal threadSession = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">public static Session getSession() throws InfrastructureException &#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (HibernateException ex) &#123;</span><br><span class="line">        throw new InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）解决线程安全的问题</p>
<p><strong>比如Java7中的SimpleDateFormat不是线程安全的</strong>，可以用ThreadLocal来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; format1 = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static String formatDate(Date date) &#123;</span><br><span class="line">        return format1.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的DateUtil.formatDate()就是线程安全的了。(Java8里的 <strong><code>java.time.format.DateTimeFormatter</code></strong><code>是线程安全的，Joda time里的DateTimeFormat也是线程安全的）。</code></p>
<p><strong>ThreadLocalRandom</strong></p>
<p>ThreadLocalRandom使用ThreadLocal的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalRandom.current().nextInt(100)</span><br></pre></td></tr></table></figure>

<h1 id="引用类型有哪些？"><a href="#引用类型有哪些？" class="headerlink" title="引用类型有哪些？"></a>引用类型有哪些？</h1><p>引用类型主要分为强软弱虚四种：</p>
<ol>
<li>强引用指的就是代码中普遍存在的赋值方式，<strong>比如A a = new A()这种</strong>。强引用关联的对象，永远不会被GC回收。</li>
<li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统<strong>在发生内存溢出前会对这类引用的对象</strong>进行回收。</li>
<li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，<strong>弱引用的对象下一次GC的时候一定会被回收</strong>，而不管内存是否足够。</li>
<li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</li>
</ol>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li>最大线程数maximumPoolSize</li>
<li>核心线程数corePoolSize</li>
<li>活跃时间keepAliveTime</li>
<li>阻塞队列workQueue</li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<p>当提交一个新任务到线程池时，具体的执行流程如下：</p>
<ol>
<li>当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务</li>
<li>当任务的数量超过corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队</li>
<li>当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待keepAliveTime之后被自动销毁</li>
<li>如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/yceQBYnWDJG3r1E.png" alt="image-20210602125235964.png"></p>
<h1 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h1><p>主要有4种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，<strong>抛出异常</strong>，这是默认策略（abort抛异常）</li>
<li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常（discard无视）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/Java%E5%9F%BA%E7%A1%80/" data-id="ckpfj9gkl000rcm0tbbmq9jcg" data-title="Java基础" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hashmap/" rel="tag">hashmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/votile/" rel="tag">votile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">权限设计</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%83%E9%99%90/">权限</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP%EF%BC%8Cjwt/" rel="tag">AOP，jwt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashmap/" rel="tag">hashmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/votile/" rel="tag">votile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/AOP%EF%BC%8Cjwt/" style="font-size: 10px;">AOP，jwt</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">Java虚拟机</a> <a href="/tags/hashmap/" style="font-size: 20px;">hashmap</a> <a href="/tags/rabbitmq/" style="font-size: 10px;">rabbitmq</a> <a href="/tags/votile/" style="font-size: 10px;">votile</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 20px;">多线程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/02/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
          </li>
        
          <li>
            <a href="/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">权限设计</a>
          </li>
        
          <li>
            <a href="/2021/05/12/mq%E5%B0%8F%E8%AE%B0/">mq小记</a>
          </li>
        
          <li>
            <a href="/2021/05/10/ThreadLocal%E5%B0%8F%E7%BB%93/">ThreadLocal小结</a>
          </li>
        
          <li>
            <a href="/2021/05/07/AOP%E5%BA%94%E7%94%A8/">AOP应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 PP<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">专栏</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
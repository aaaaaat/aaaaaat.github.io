<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>小胖的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="随心笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="小胖的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="小胖的博客">
<meta property="og:description" content="随心笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PP">
<meta property="article:tag" content="随心笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小胖的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小胖的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">记录备战秋招的点点滴滴</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">专栏</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-url输入到返回请求的过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/url%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T15:14:45.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/url%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/">url输入到返回请求的过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>首先进行url解析，根据dns系统进行ip查找</p>
<p>为什么url要解析？</p>
<p>因为网络标准规定了URL只能是字母和数字，还有一些其它特殊符号（-_.~ ! * ‘ ( ) ; : @ &amp; = + $ , / ? # [ ]，比较常见的就是不包括百分号和双引号），而且如果不转义会出现歧义，比如<code>http:www.baidu.com?key=value</code>,假如我的<code>key</code>本身就包括等于<code>=</code>符号，比如<code>ke=y=value</code>，就会出现歧义，你不知道<code>=</code>到底是连接<code>key</code>和<code>value</code>的符号，还是说本身<code>key</code>里面就有<code>=</code>。</p>
<p>大佬接着毒打我说，那 url 编码的规则是什么呢，我说 utf-8</p>
<p>大佬接着穷追不舍，为啥是 utf-8 呢，所有浏览器都是这样吗？</p>
<p>中文的话用 gb2312 编码吗，还有就是万一浏览器不是你说的这样统一用 utf-8，你怎么保证都是 utf-8 的编码?</p>
<p>我支支吾吾的说：我了解的大概是这样，不太清楚, 应该和 html 本身的编码格式有关，然后怎么保证 utf-8 的编码，我觉得可以用 encodeURIComponent</p>
</li>
</ul>
<p>​       <strong>encodeURIComponent 比 encodeURI 有什么区别?</strong></p>
<p>​       区别就是encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码,当然项目里一         般都是用qs库去处理</p>
<p>​      <strong>说说 dns 解析流程，并且 html 如何做 dns 优化？</strong></p>
<p>比如说查询一个网址为：<a target="_blank" rel="noopener" href="http://www.baidu.com(非转发模式)/">www.baidu.com（非转发模式）</a></p>
<p>1、器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 域名，操作系统会先查 hosts 件是否有记录，有的话就会把相对应映射的IP返回。</p>
<p>2、hosts 文件没有就去查本地 dns 解析器有没有缓存。（这个我没答上来）</p>
<p>3、然后就去找我们计算机上配置的 dns 服务器上有或者有缓存，就返回</p>
<p>4、还没有的话就去找根 DNS 服务器(全球13台，固定ip地址)，然后判断 .com 域名是哪个服务器管理，如果无法解析，就查找 .baidu.com 服务器是否能解析，直到查到<a target="_blank" rel="noopener" href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a></p>
<p>前端的 dns 优化，可以在 html 页面头部写入 dns 缓存地址，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查找到 IP 之后，就是 http 协议的三次握手（以及后面会涉及到四次分手）</strong></li>
</ul>
<p>第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后知道A要求建立连接;</p>
<p>第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；</p>
<p>主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1</p>
<p>第三次握手：若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</p>
<p><strong>为什么两次握手不行？</strong></p>
<p>因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。</p>
<p><strong>从网卡把数据包传输出去到服务器发生了什么？提示我 OSI 参考模型</strong></p>
<p>先从局域网把数据发送到公司的交换机（如果交换机没有缓存本地mac地址和IP地址的映射，此时会通过ARP协议来获得），交换机的好处是可以隔离冲突域（因为以太网用的是CSMA/CD协议,这个协议规定网线上同一时刻只能有一台机器发送数据），这样就可以不仅仅同一时刻只有一台机器发送网络包了</p>
<p>然后交换机再将数据发送到路由器，路由器相当于公司网关（我们公司小），路由器具有转发和分组数据包的功能（路由器通过选定的路由协议会构造出路由表，同时不定期的跟相邻路由器交换路由信息），然后这算是经过了物理层，数据链路层（以太网）,开始到网络层进行数据转发了</p>
<p>然后路由器转发IP数据报，一般公司的IP地址都会经过NAT转换，让内网的ip也能够访问外网，我们公司我注意了一下是192.168打头的内网ip地址。</p>
<p>通过路由器的分组传输，所有数据到达服务器。</p>
<p>然后服务器的上层协议传输层协议开始发挥作用，根据 tcp 包里的端口号，让服务器特定的服务来处理到来的数据包，并且 tcp 是面向字节流的(tcp有四大特性，可靠传输、流量控制、拥塞控制、连接管理)，所以我们 node 的 request 对象，它的监听事件 data 事件为什么要用字符串一起拼接起来呢（buffer），就是因为tcp本身就是字节流，request 对象使用的 data（http层面）是 tcp 传来的数据块。</p>
<p>最后数据由传输层转交给应用层，也就是http服务（或者https），后端经过一系列逻辑处理，返回给前端数据。</p>
<ul>
<li><p><strong>建立完链接，就该请求html文件了，如果html文件在缓存里面浏览器直接返回，如果没有，就去后台拿</strong></p>
<p><strong>缓存？</strong></p>
</li>
</ul>
<p>浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;</p>
<p>下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存</p>
<p>协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;</p>
<p>协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;</p>
<p><strong>什么是from disk cache和from memory cache吗，什么时候会触发？</strong></p>
<p>我说强缓存会触发，这两种，具体什么行为不知道,大概内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、先查找内存，如果内存中存在，从内存中加载；</span><br><span class="line">2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；</span><br><span class="line">3、如果硬盘中未查找到，那就进行网络请求；</span><br><span class="line">4、加载到的资源缓存到硬盘和内存</span><br></pre></td></tr></table></figure>

<p><strong>启发式缓存:</strong></p>
<p>如果响应中未显示Expires，Cache-Control：max-age或Cache-Control：s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Date 减去 Last-Modified 值的 10% 作为缓存时间。</span><br><span class="line">// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间</span><br><span class="line">  response_is_fresh = max(0,（Date - Last-Modified)) % 10</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>返回html之后，会解析html</strong></p>
<p><strong>cssom + domTree = html,然后布局和绘制</strong></p>
<p>构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；</p>
<p>构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；</p>
<p>执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；</p>
<p>构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；</p>
<p>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。</p>
<p>布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；</p>
<p>绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；</p>
<h3 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a><strong>页面渲染优化</strong></h3><ul>
<li>HTML文档结构层次尽量少，最好不深于六层；</li>
<li>脚本尽量后放，放在前即可；</li>
<li>少量首屏样式内联放在标签内；</li>
<li>样式结构层次尽量简单；</li>
<li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；</li>
<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>
<li>动画尽量使用在绝对定位或固定定位的元素上；</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li>
<li>尽量缓存DOM查找，查找器尽量简洁；</li>
<li>涉及多域名的网站，可以开启域名预解析</li>
</ul>
</li>
<li><p>如何诊断页面渲染时各个性能指标，我大概说了，通过chrome浏览器的工具，比如看网络请求情况的network，还有看页面渲染情况的perfermance</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/url%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/" data-id="ckpfnky930000ps0tffjg957h" data-title="url输入到返回请求的过程" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-实现线程的方式只有一种" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T14:29:41.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/">线程的实现</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D/">实现线程的方式只有一种</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们先不聚焦为什么说创建线程只有一种方式，先认为有两种创建线程的方式，而其他的创建方式，比如线程池或是定时器，它们仅仅是在 new Thread() 外做了一层封装，如果我们把这些都叫作一种新的方式，那么创建线程的方式便会千变万化、层出不穷，比如 JDK 更新了，它可能会多出几个类，会把 new Thread() 重新封装，表面上看又会是一种新的实现线程的方式，透过现象看本质，打开封装后，会发现它们最终都是基于 Runnable 接口或继承 Thread 类实现的。</p>
<p>接下来，我们进行更深层次的探讨，为什么说这两种方式本质上是一种呢？</p>
<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 种方式是通过实现 Runnable 接口实现多线程（需要重写run方法，但还是需要将RunnableThread传入Thread中，调用Thread的start方法启动多线程），如代码所示，首先通过 RunnableThread 类实现 Runnable 接口，然后重写 run() 方法，之后<strong>只需要把这个实现了 run() 方法的实例传到 Thread 类中就可以实现多线程。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，启动线程需要调用 start() 方法，<strong>而 start() 方法最终还会调用 run() 方法</strong></p>
<p>我们先来看看第一种方式（基于Runnable接口）中 run() 方法究竟是怎么实现的，可以看出 run() 方法的代码非常短小精悍。</p>
<ul>
<li><p>第 1 行代码 <strong>if (target != null)</strong> ，判断 target 是否等于 null</p>
</li>
<li><p>如果不等于 null，就执行第 2 行代码 target.run()</p>
<p><strong>而 target 实际上就是一个 Runnable（即使用 Runnable 接口实现线程时传给Thread类的对象）</strong></p>
</li>
</ul>
<p>我们来看第二种方式，也就是继承 Thread 方式（也就是说继承了Thread的start方法）</p>
<ul>
<li><p>实际上，继承 Thread 类之后，<strong>会把上述的 run() 方法重写</strong>，重写后 run() 方法里直接就是所需要执行的任务</p>
</li>
<li><p>但它最终还是需要调用 thread.start() 方法来启动线程。</p>
</li>
<li><p>而 start() 方法最终也会调用<strong>这个已经被重写的 run() 方法</strong>来执行它的任务</p>
</li>
</ul>
<p>这时我们就可以彻底明白了，事实上<strong>创建线程只有一种方式，就是构造一个 Thread 类，这是创建线程的唯一方式。</strong></p>
<p>两种创建线程方式本质上是一样的，它们的不同点仅仅在于<strong>实现线程运行内容的不同</strong>，那么运行内容来自于哪里呢？</p>
<p>运行内容主要来自于两个地方，要么来自于 target，要么来自于重写的 run() 方法。</p>
<p>在此基础上我们进行拓展，可以这样描述：本质上，实现线程只有一种方式，<strong>而要想实现线程执行的内容，却有两种方式</strong>，也就是可以通过 实现 Runnable 接口的方式（@Override run方法），或是继承 Thread 类重写 run() 方法的方式，把我们想要执行的代码传入，让线程去执行，在此基础上，如果我们还想有更多实现线程的方式，比如线程池和 Timer 定时器，只需要在此基础上进行封装即可。</p>
<h3 id="实现-Runnable-接口比继承-Thread-类实现线程要好"><a href="#实现-Runnable-接口比继承-Thread-类实现线程要好" class="headerlink" title="实现 Runnable 接口比继承 Thread 类实现线程要好"></a>实现 Runnable 接口比继承 Thread 类实现线程要好</h3><p>下面我们来对刚才说的两种实现线程内容的方式进行对比，也就是为什么说实现 Runnable 接口比继承 Thread 类实现线程要好？好在哪里呢？</p>
<ul>
<li><p>首先，我们从代码的架构考虑，实际上，<strong>Runnable 里只有一个 run() 方法，它定义了需要执行的内容</strong>，在这种情况下，实现了 Runnable 与 Thread 类的解耦，<strong>Thread 类负责线程启动和属性设置等内容</strong>，权责分明。</p>
</li>
<li><p>第二点就是在某些情况下可以提高性能，使用继承 Thread 类方式，<strong>每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类</strong>，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。<strong>如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池（ public Thread newThread(Runnable r) {}），使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</strong></p>
<p>线程池是怎么实现线程的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">            Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line">            <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                  <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，<strong>默认采用 DefaultThreadFactory ，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程，以及线程的优先级等。</strong>但是无论怎么设置这些属性，最终它还是通过 new Thread() 创建线程的 ，只不过这里的构造函数传入的参数要多一些，由此可以看出通过线程池创建线程并没有脱离最开始的那两种基本的创建方式，因为本质上还是通过 new Thread() 实现的。</p>
</li>
<li><p>第三点好处在于 Java 语言不支持双继承，<strong>如果我们的类一旦继承了 Thread 类，那么它后续就没有办法再继承其他的类</strong>，这样一来，如果未来这个类需要继承其他类实现一些功能上的拓展，它就没有办法做到了，相当于限制了代码未来的可拓展性。</p>
</li>
</ul>
<p>综上所述，我们应该优先选择通过实现 Runnable 接口的方式来创建线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D/" data-id="ckpfltdxp0000n80t5hej87pg" data-title="实现线程的方式只有一种" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/02/Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-06-02T05:54:29.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/02/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程是程序的一次执行，是系统进行资源分配和调度的独立单位。</li>
</ul>
<p>​       作用：程序能够并发执行提高资源利用率和吞吐率</p>
<hr>
<p><strong>为什么用线程？</strong></p>
<p>1、由于进程是资源分配和调度的资本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多。</p>
<p>2、线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。</p>
<hr>
<ul>
<li>线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。</li>
</ul>
<h1 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h1><ul>
<li><p>java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong></p>
</li>
<li><p>使用synchronized之后，会在编译之后在<strong>同步的代码块前后加上monitorenter和monitorexit字节码指令</strong>，他依赖操作系统底层互斥锁实现（作用：实现原子性操作和解决共享变量的内存可见性问题）</p>
<p>1、执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。<strong>此时其他竞争锁的线程则会进入等待队列中。</strong></p>
<p>2、执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。</p>
</li>
<li><p><strong>synchronized是排它锁</strong>，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，</p>
<p>1、而且由于Java中的线程和操作系统原生线程是一一对应的，<strong>线程被阻塞或者唤醒时时会从用户态切换到内核态</strong>，这种转换非常消耗性能。</p>
<p>2、从内存语义来说，加锁的过程会<strong>清除工作内存中的共享变量（用户态</strong>），再<strong>从主内存读取（内核态）</strong>，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p>
</li>
<li><p>synchronized实际上有<strong>两个队列waitSet和entryList</strong>：<br>1、当多个线程进入同步代码块时，首先进入entryList</p>
<p>2、有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1</p>
<p>3、<strong>如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</strong></p>
<p>4、如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/02/CFLQGe1HsE7Ppit.png" alt="image-20210602093422755.png"></p>
<h1 id="锁的优化机制"><a href="#锁的优化机制" class="headerlink" title="锁的优化机制"></a>锁的优化机制</h1><p>从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<p>锁的状态从低到高依次为<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
<hr>
<ul>
<li><p><strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。<strong>自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态</strong>，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。</p>
</li>
<li><p><strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，<strong>而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
</li>
<li><p><strong>锁粗化</strong>：锁粗化指的是<strong>有很多操作都是对同一个对象进行加锁</strong>，就会把<strong>锁的同步范围扩展到整个操作序列之外。</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>偏向锁</strong>：当线程访问同步块获取锁时，<strong>会在对象头和栈帧中的锁记录里存储偏向锁的线程ID</strong>，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，<strong>当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁</strong>。可以用过设置-XX:+UseBiasedLocking开启偏向锁。</p>
</li>
<li><p><strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，<strong>JVM将会使用CAS方式来尝试获取锁（发生竞争），如果更新成功则会把对象头中的状态位标记为轻量级锁</strong>，如果更新失败，当前线程就尝试自旋来获得锁。</p>
</li>
</ul>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<p><img src="https://i.loli.net/2021/06/02/E5oHDMeuQiJNzZg.png" alt="image-20210602093705252.png"></p>
<hr>
<p>为什么升级轻量级锁后，要在当前线程栈帧创建锁记录空间，并将Mark word复制到锁空间？</p>
<p>线程以轻量级锁(Fast Lock)的方式进入同步块时，先在当前的活动记录(Activation Record)，就是我们平时所说的栈帧中分配一个Lock Record，用以复制当前锁对象Object Header中的markWord——displaced_header；然后尝试使用CAS的方式将对象的mark完全替换为刚刚在栈上（On-Stack）中分配的Lock Record的指针（就是这个锁记录的地址）——刚好HotSpot VM会确保这个地址的后两位是清零的，就是“00”——所谓的轻量级锁的状态。</p>
<p>如果CAS失败了呢，“说明此时有其它线程获取了锁，此时markword应该指向其它线程的栈帧了”只涉及到了一种情况；与此同时<strong>还有一种情况就是可能线程以递归的方式再次去获得轻量级锁——说明线程之前已经获得锁了，活动记录中已经存在一个锁对象markword对应的Lock Record了，这个Lock Record显然与再次进入同步块时在栈帧中创建的锁记录不是同一个，CAS操作无遗会失败。在这种情况下，栈帧中的锁对象会被置零。——这就是为什么要再次判断线程是否获得锁的原因。</strong></p>
<h1 id="对象头具体包含哪些内容"><a href="#对象头具体包含哪些内容" class="headerlink" title="对象头具体包含哪些内容"></a>对象头具体包含哪些内容</h1><p>在我们常用的Hotspot虚拟机中，对象在内存中布局实际包含3个部分：</p>
<ol>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<p>而对象头包含两部分内容，<strong>Mark Word中的内容会随着锁标志位而发生变化</strong>，所以只说存储结构就好了。</p>
<ol>
<li>对象自身运行时所需的数据，也被称为Mark Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。</li>
<li>存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。</li>
</ol>
<p><em>如果是数组的话，则还包含了数组的长度</em></p>
<p><img src="https://i.loli.net/2021/06/02/1waijkvbfJO7qhM.png" alt="image-20210602095242045.png"></p>
<h1 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h1><p>相比于synchronized，<strong>ReentrantLock需要显式的获取锁和释放锁</strong>，相对现在基本都是用JDK7和JDK8的版本，ReentrantLock的效率和synchronized区别基本可以持平了。</p>
<hr>
<p>他们的主要区别有以下几点：</p>
<ol>
<li><strong>等待可中断</strong>，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。</li>
<li><strong>公平锁</strong>：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。</li>
<li><strong>绑定多个条件</strong>：ReentrantLock可以同时绑定多个Condition条件对象。</li>
</ol>
<p>ReentrantLock基于AQS(<strong>AbstractQueuedSynchronizer 抽象队列同步器</strong>)实现。</p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>AQS内部维护一个state状态位，尝试加锁的时候通过CAS(CompareAndSwap)修改值，<strong>如果成功设置为1，并且把当前线程ID赋值</strong>，则代表加锁成功，一旦获取到锁，其他的线程将会被阻塞进入阻塞队列自旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，<strong>释放锁的时候则会把state重新置为0，同时当前线程ID置为空。</strong></p>
<p><img src="https://i.loli.net/2021/06/02/HEeCUAIZJtF9cmN.png" alt="image-20210602100735320.png"></p>
<h1 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h1><p>CAS叫做CompareAndSwap，比较并交换，<strong>主要是通过处理器的指令来保证操作的原子性</strong>，它包含三个操作数：</p>
<ol>
<li>变量内存地址，V表示</li>
<li>旧的预期值，A表示</li>
<li>准备设置的新值，B表示</li>
</ol>
<p>当执行CAS指令时，<strong>只有当V等于A时</strong>，才会用B去更新V的值，否则就不会执行更新操作。</p>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><p>CAS的缺点主要有3点：</p>
<ul>
<li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。</li>
</ul>
<p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<ul>
<li><p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</p>
</li>
</ul>
<h1 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h1><p>HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是<strong>put插入数据的过程，get查询数据以及扩容的方式</strong>。<strong>JDK1.7和1.8的主要区别在于头插和尾插方式的修改</strong>，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。</p>
<hr>
<h2 id="put插入数据流程"><a href="#put插入数据流程" class="headerlink" title="put插入数据流程"></a>put插入数据流程</h2><p>1、往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&amp;hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。</p>
<p>2、找到数组中的位置之后，如果数组中没有元素直接存入</p>
<p>3、反之则判断key是否相同，key相同就覆盖</p>
<p>4、否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成红黑树</p>
<p><strong>5、最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。</strong></p>
<h2 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h2><p>一般如果<code>new HashMap()</code> 不传值，默认大小是 16，负载因子是 0.75， 如果自己<strong>传入初始大小 k，初始化大小为大于 k 的 2 的整数次方</strong>。</p>
<p>例如如果传 10，大小为 16（传入k=50，大小为2的6次方）。</p>
<p>算法就是让初始二进制分别右移 1，2，4，8，16位，与自己异或，把高位第一个为 1 的数通过不断右移，把高位为 1 的后面全变为 1，111111 + 1 = 1000000 = 2的6次方（符合大于 50 并且是 2 的整数次幂 ） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123; </span><br><span class="line">int n = cap - 1;  </span><br><span class="line">n |= n &gt;&gt;&gt; 1; </span><br><span class="line">n |= n &gt;&gt;&gt; 2; </span><br><span class="line">n |= n &gt;&gt;&gt; 4; </span><br><span class="line">n |= n &gt;&gt;&gt; 8;  </span><br><span class="line">n |= n &gt;&gt;&gt; 16; </span><br><span class="line">return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么-HashMap-的数组长度要取-2-的整数幂"><a href="#为什么-HashMap-的数组长度要取-2-的整数幂" class="headerlink" title="为什么 HashMap 的数组长度要取 2 的整数幂?"></a>为什么 HashMap 的数组长度要取 2 的整数幂?</h2><p>因为这样（数组长度 -1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10100101 11000100 00100101</span><br><span class="line">&amp; 00000000 00000000 00001111</span><br><span class="line">----------------------------------  </span><br><span class="line">  00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-是线程安全的吗？"><a href="#HashMap-是线程安全的吗？" class="headerlink" title="HashMap 是线程安全的吗？"></a><strong>HashMap 是线程安全的吗？</strong></h2><p>不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有<strong>数据覆盖、多线程同时扩容</strong>的问题。</p>
<h2 id="那你平常怎么解决这个线程不安全的问题？"><a href="#那你平常怎么解决这个线程不安全的问题？" class="headerlink" title="那你平常怎么解决这个线程不安全的问题？"></a><strong>那你平常怎么解决这个线程不安全的问题？</strong></h2><p>Java 中有 <strong>HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap</strong> 可以实现线程安全的 Map。</p>
<ol>
<li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大；</li>
<li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li>
<li>ConcurrentHashMap 使用分段锁，降低了锁粒度，让并发度大大提高。</li>
</ol>
<h2 id="JDK1-8的优化"><a href="#JDK1-8的优化" class="headerlink" title="JDK1.8的优化"></a>JDK1.8的优化</h2><p>1、<strong>数组+链表改成了数组+链表或红黑树</strong>；</p>
<p>防止发生 hash 冲突，链表长度过长，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code>；</p>
<p>2、链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，<strong>1.8 遍历链表，将元素放置到链表的最后；</strong></p>
<p> A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环。</p>
<p>3、扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，<strong>1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小；</strong></p>
<p>这是由于扩容是扩大为原数组大小的 2 倍，用于计算数组位置的掩码仅仅只是高位多了一个 1，举个例子：</p>
<p>扩容前长度为 16，用于计算 <strong>(n-1) &amp; hash</strong> 的二进制 n - 1 为 0000 1111，</p>
<p>扩容后为 32 后的二进制就高位多了 1，———————–&gt;为 0001 1111。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>多线程环境可以使用</p>
<ul>
<li>Collections.synchronizedMap同步加锁的方式</li>
<li>还可以使用HashTable</li>
<li>但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li>
</ul>
<p>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</p>
<h3 id="1-7分段锁"><a href="#1-7分段锁" class="headerlink" title="1.7分段锁"></a><strong>1.7分段锁</strong></h3><p>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，<strong>Segment继承与ReentrantLock，Segment则包含HashEntry的数组</strong>，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p>
<p><strong>实际上就是相当于每个Segment都是一个HashMap</strong>，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p>
<p>1、成员变量使用 volatile 修饰，免除了指令重排序，同时保证内存可见性</p>
<p>2、另外使用 CAS 操作和 synchronized 结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p>
<h4 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a><strong>put流程</strong></h4><p>其实发现整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程我就简化了，因为和HashMap基本上是一样的。</p>
<ol>
<li>计算hash，定位到segment，segment如果是空就先初始化</li>
<li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li>
<li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样</li>
</ol>
<h3 id="1-8CAS-synchronized"><a href="#1-8CAS-synchronized" class="headerlink" title="1.8CAS+synchronized"></a><strong>1.8CAS+synchronized</strong></h3><p>1.8抛弃分段锁，转为用CAS+synchronized来实现，同样HashEntry改为Node，也加入了红黑树的实现。主要还是看put的流程。</p>
<h4 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a><strong>put流程</strong></h4><ol>
<li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li>
<li>如果当前数组位置是空则直接通过CAS自旋写入数据</li>
<li>如果hash==MOVED，说明需要扩容，执行扩容</li>
<li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/cIDKTHCXrtJMYfd.png" alt="image-20210602104739991.png"></p>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，他没有上下文切换的额外开销成本。</p>
<hr>
<p>使用volatile声明的变量，可以确保值被更新的时候对其他线程立刻可见。</p>
<ul>
<li><strong>volatile使用内存屏障来保证不会发生指令重排</strong>，解决了内存可见性的问题。</li>
</ul>
<p>我们知道，线程都是从主内存中读取共享变量到工作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可见性问题。</p>
<p>举个例子，假设现在我们是<strong>两级缓存的双核CPU架构，包含L1、L2两级缓存。</strong></p>
<ol>
<li><p>线程A首先获取变量X的值，由于最初两级缓存都是空，所以直接从主内存中读取X，假设X初始值为0，线程A读取之后把X值都修改为1，同时写回主内存。这时候缓存和主内存的情况如下图。</p>
<img src="https://i.loli.net/2021/06/02/4odVRfM3hpYZSB2.png" alt="image-20210602110335935.png" style="zoom: 33%;" /></li>
</ol>
<p> 线程B也同样读取变量X的值，由于L2缓存已经有缓存X=1，所以直接从L2缓存读取，之后线程B把X修改为2，同时写回L2和主内存。这时候的X值入下图所示。</p>
<p>那么线程A如果再想获取变量X的值，<strong>因为L1缓存已经有x=1了，所以这时候变量内存不可见问题就产生了，B修改为2的值对A来说没有感知。</strong></p>
<img src="https://i.loli.net/2021/06/02/U5JGET4xbBVvqkm.png" alt="image-20210602110515392.png" style="zoom:33%;" />

<p>那么，如果X变量用volatile修饰的话，当线程A再次读取变量X的话，<strong>CPU就会根据缓存一致性协议强制线程A重新从主内存加载最新的值到自己的工作内存，而不是直接用缓存中的值。</strong></p>
<h2 id="缓存一致性协议与volatile"><a href="#缓存一致性协议与volatile" class="headerlink" title="缓存一致性协议与volatile"></a>缓存一致性协议与volatile</h2><p>volatile是Java这种高级语言中的一个关键字，要实现这个volatile的功能，需要借助MESI！（<strong>请注意，这里只是说Java的volatile，而不涵盖C和C++的volatile</strong>）</p>
<p>CPU有缓存一致性协议：MESI，这不错。但MESI并非是无条件生效的！</p>
<p>不是说CPU支持MESI，那么你的变量就默认能做到缓存一致了。</p>
<p>根据MESI，CPU某核（假设CPU0）的缓存行（包含变量x）是M、S、或E的时候，如果总线嗅探到了变量x被其其他核（比如CPU1）执行了写操作（remote write）那么CPU0中的该缓存行会置为I（无效），在CPU0后续对该变量执行读操作的时候，发现是I状态，就会去主存中同步最新的值（其实由于L3缓存的存在，这里也可能是直接从L3同步到CPU0的L1和L2缓存，而不直接访问主存）</p>
<p>但实际可能不太理想，因为在CPU1执行写操作，要等到其他CPU（比如CPU0、CPU2……）将对应缓存行置为I状态，然后再将数据同步到主存，这个写操作才能完成。由于这样性能较差所以引入了Store Buffer，CPU1只需要将数据写入到Store Buffer，而不等待其他CPU把缓存行状态置为I，就开始忙别的去了。等到其他CPU通知CPU1我们都知道那个缓存失效啦，然后这个数据才同步到主存。</p>
<p>java虚拟机在实现volatile关键字的时候，是写入了一条lock 前缀的汇编指令。</p>
<p><strong>lock 前缀的汇编指令会强制写入主存，也可避免前后指令的CPU重排序，并及时让其他核中的相应缓存行失效，从而利用MESI达到符合预期的效果。</strong></p>
<p>非lock前缀的汇编指令在执行写操作的时候，可能是是不生效的。比如前面所说的Store Buffer的存在，lock前缀的指令在功能上可以等价于内存屏障，可以让其立即刷入主存。</p>
<p>再来介绍一下何谓lock前缀指令。lock指令在汇编中不是单独出现的，而是作为前缀来修饰其他指令的。可以和lock前缀修饰的指令有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG,DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock addl $0×0, (%esp)</span><br></pre></td></tr></table></figure>

<p>addl指令执行的时候会触发一个LOCK#信号，锁缓存(独占变量所在缓存行），指令执行完毕之后锁定解除。注意addl $0×0, (%esp)是一个空操作，不会有任何影响，这里只是为了配合触发lock的效果</p>
<p>是volatile的底层实现，满足了MESI的触发条件，才让变量有了缓存一致性。</p>
<h2 id="内存屏障的问题"><a href="#内存屏障的问题" class="headerlink" title="内存屏障的问题"></a>内存屏障的问题</h2><p>volatile修饰之后会加入不同的内存屏障来保证可见性的问题能正确执行。这里写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不一样，比如x86平台上，只有StoreLoad一种内存屏障。</p>
<ol>
<li>StoreStore屏障，保证上面的普通写不和volatile写发生重排序</li>
<li>StoreLoad屏障，保证volatile写与后面可能的volatile读写不发生重排序</li>
<li>LoadLoad屏障，禁止volatile读与后面的普通读重排序</li>
<li>LoadStore屏障，禁止volatile读和后面的普通写重排序</li>
</ol>
<img src="https://i.loli.net/2021/06/02/lgdUjSfQ5kJhuM1.png" alt="image-20210602111851692.png" style="zoom:33%;" />

<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加入了高速缓存，高速缓存一般可以分为L1、L2、L3三级缓存。基于上面的例子我们知道了这导致了缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU的重排序导致了原子性和有序性的问题，JMM内存模型正是对多线程操作下的一系列规范约束，因为不可能让陈雇员的代码去兼容所有的CPU，<strong>通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到一致的内存访问效果，同时也是保证在高效并发的时候程序能够正确执行。</strong></p>
<img src="https://i.loli.net/2021/06/02/Uqxrju2AfYhD1dE.png" alt="image-20210602112233460.png" style="zoom:33%;" />

<ul>
<li><p><strong>原子性</strong>：Java内存模型通过read、load、assign、use、store、write来保证原子性操作，此外还有lock和unlock，直接对应着synchronized关键字的monitorenter和monitorexit字节码指令。</p>
</li>
<li><p><strong>可见性</strong>：可见性的问题在上面的回答已经说过，Java保证可见性可以认为通过volatile、synchronized、final来实现。</p>
</li>
<li><p><strong>有序性</strong>：由于处理器和编译器的重排序导致的有序性问题，Java通过volatile、synchronized来保证。</p>
</li>
</ul>
<h4 id="volatile和synchronize的比较："><a href="#volatile和synchronize的比较：" class="headerlink" title="volatile和synchronize的比较："></a>volatile和synchronize的比较：</h4><p>1.volatile是线程同步的轻量级实现，所以volatile的性能要比synchronize好；<br>   volatile只能用于修饰变量，synchronize可以用于修饰方法、代码块。随着jdk技术的发展，synchronize在执行效率上会得到较大提升，所以synchronize在项目过程中还是较为常见的；</p>
<p>2.多线程访问volatile不会发生阻塞；而synchronize会发生阻塞；</p>
<p>3.volatile能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize可以保证变量原子性；</p>
<p>4.volatile是变量在多线程之间的可见性；synchronize是多线程之间访问资源的同步性；</p>
<p>对于volatile修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。</p>
<h4 id="happen-before规则"><a href="#happen-before规则" class="headerlink" title="happen-before规则"></a><strong>happen-before规则</strong></h4><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：</p>
<ol>
<li>单线程每个操作，happen-before于该线程中任意后续操作</li>
<li>volatile写happen-before与后续对这个变量的读</li>
<li>synchronized解锁happen-before后续对这个锁的加锁</li>
<li>final变量的写happen-before于final域对象的读，happen-before后续对final变量的读</li>
<li>传递性规则，A先于B，B先于C，那么A一定先于C发生</li>
</ol>
<h4 id="工作内存和主内存"><a href="#工作内存和主内存" class="headerlink" title="工作内存和主内存"></a>工作内存和主内存</h4><ul>
<li><p>主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。</p>
</li>
<li><p>而工作内存就是CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。</p>
</li>
</ul>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><strong>什么是ThreadLocal变量</strong></p>
<p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。</li>
<li>既然每个 Thread 有自己的实例副本，<strong>且其它 Thread 不可访问</strong>，那就不存在多线程间共享的问题。</li>
</ul>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
<p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例<strong>且该实例需要在多个方法中被使用</strong>，也即变量在线程间隔离而在方法或类间共享的场景。</p>
<p><strong>ThreadLocal实现原理</strong></p>
<p>首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。</p>
<p>因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 set 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;   </span><br><span class="line">    Thread t = Thread.currentThread();   </span><br><span class="line">    ThreadLocalMap map = getMap(t);   </span><br><span class="line">    if (map != null)   </span><br><span class="line">        return (T)map.get(this);   </span><br><span class="line">  </span><br><span class="line">    // Maps are constructed lazily.  if the map for this thread   </span><br><span class="line">    // doesn&#x27;t exist, create it, with this ThreadLocal and its   </span><br><span class="line">    // initial value as its only entry.   </span><br><span class="line">    T value = initialValue();   </span><br><span class="line">    createMap(t, value);   </span><br><span class="line">    return value;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>createMap方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;   </span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap是个静态的内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;   </span><br><span class="line">........   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中</strong>，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p>
<h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a><strong>内存泄漏问题</strong></h2><p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉<strong>。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</strong></p>
<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，<strong>那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</strong></p>
<p>建议回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。 <strong>尽量在代理中使用try-finally块进行回收</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objectThreadLocal.set(userInfo); </span><br><span class="line">try &#123;</span><br><span class="line">    // ... </span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">    objectThreadLocal.remove(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<p>如上文所述，ThreadLocal 适用于如下两种场景</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>对于第一点，每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。</p>
<p>对于第二点，可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅。</p>
<p>1）存储用户Session</p>
<p>一个简单的用ThreadLocal来存储Session的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal threadSession = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">public static Session getSession() throws InfrastructureException &#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (HibernateException ex) &#123;</span><br><span class="line">        throw new InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）解决线程安全的问题</p>
<p><strong>比如Java7中的SimpleDateFormat不是线程安全的</strong>，可以用ThreadLocal来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; format1 = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static String formatDate(Date date) &#123;</span><br><span class="line">        return format1.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的DateUtil.formatDate()就是线程安全的了。(Java8里的 <strong><code>java.time.format.DateTimeFormatter</code></strong><code>是线程安全的，Joda time里的DateTimeFormat也是线程安全的）。</code></p>
<p><strong>ThreadLocalRandom</strong></p>
<p>ThreadLocalRandom使用ThreadLocal的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalRandom.current().nextInt(100)</span><br></pre></td></tr></table></figure>

<h1 id="引用类型有哪些？"><a href="#引用类型有哪些？" class="headerlink" title="引用类型有哪些？"></a>引用类型有哪些？</h1><p>引用类型主要分为强软弱虚四种：</p>
<ol>
<li>强引用指的就是代码中普遍存在的赋值方式，<strong>比如A a = new A()这种</strong>。强引用关联的对象，永远不会被GC回收。</li>
<li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统<strong>在发生内存溢出前会对这类引用的对象</strong>进行回收。</li>
<li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，<strong>弱引用的对象下一次GC的时候一定会被回收</strong>，而不管内存是否足够。</li>
<li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</li>
</ol>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li>最大线程数maximumPoolSize</li>
<li>核心线程数corePoolSize</li>
<li>活跃时间keepAliveTime</li>
<li>阻塞队列workQueue</li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<p>当提交一个新任务到线程池时，具体的执行流程如下：</p>
<ol>
<li>当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务</li>
<li>当任务的数量超过corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队</li>
<li>当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待keepAliveTime之后被自动销毁</li>
<li>如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</li>
</ol>
<p><img src="https://i.loli.net/2021/06/02/yceQBYnWDJG3r1E.png" alt="image-20210602125235964.png"></p>
<h1 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h1><p>主要有4种拒绝策略：</p>
<ol>
<li>AbortPolicy：直接丢弃任务，<strong>抛出异常</strong>，这是默认策略（abort抛异常）</li>
<li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li>
<li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务，也不抛出异常（discard无视）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/02/Java%E5%9F%BA%E7%A1%80/" data-id="ckpfj9gkl000rcm0tbbmq9jcg" data-title="Java基础" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hashmap/" rel="tag">hashmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/votile/" rel="tag">votile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-权限控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-20T13:47:45.000Z" itemprop="datePublished">2021-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%83%E9%99%90/">权限</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">权限设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-表达式控制-URL-路径权限"><a href="#1-表达式控制-URL-路径权限" class="headerlink" title="1.表达式控制 URL 路径权限"></a>1.表达式控制 URL 路径权限</h2><p>首先我们来看第一种，就是通过表达式控制 URL 路径权限。</p>
<p>Spring Security 支持在 URL 和方法权限控制时使用 <strong>SpEL 表达式</strong>，如果表达式返回值为 true 则表示需要对应的权限，否则表示不需要对应的权限。提供表达式的类是 SecurityExpressionRoot</p>
<p>SecurityExpressionRoot 有两个实现类，表示在应对 URL 权限控制和应对方法权限控制时，分别对 SpEL 所做的拓展，例如<strong>在基于 URL 路径做权限控制时，增加了 hasIpAddress 选项。</strong></p>
<p>如果是通过 URL 进行权限控制，那么我们只需要按照如下方式配置即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/**&quot;</span>).hasAnyRole(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里表示访问 <code>/admin/**</code> 格式的路径需要 admin 角色，访问 <code>/user/**</code> 格式的路径需要 admin 或者 user 角色。</p>
<h2 id="2-表达式控制方法权限"><a href="#2-表达式控制方法权限" class="headerlink" title="2.表达式控制方法权限"></a>2.表达式控制方法权限</h2><p>当然，我们也可以通过在方法上添加注解来控制权限。</p>
<p>在方法上添加注解控制权限，需要我们首先开启注解的使用，在 Spring Security 配置类上添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置开启了三个注解，分别是：</p>
<ul>
<li>@PreAuthorize：方法执行前进行权限检查</li>
<li>@PostAuthorize：方法执行后进行权限检查</li>
<li>@Secured：类似于 @PreAuthorize</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;principal.username.equals(&#x27;javaboy&#x27;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;admin&#x27;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Secured(&#123;&quot;ROLE_user&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;#age&gt;98&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个 hello 方法，注解的约束是，只有当前登录用户名为 javaboy 的用户才可以访问该方法。</li>
<li>第二个 admin 方法，表示访问该方法的用户必须具备 admin 角色。</li>
<li>第三个 user 方法，表示方法该方法的用户必须具备 user 角色，但是注意 user 角色需要加上 <code>ROLE_</code> 前缀。</li>
<li><strong>第四个 getAge 方法，表示访问该方法的 age 参数必须大于 98，否则请求不予通过。</strong></li>
</ol>
<p>可以看到，这里的表达式还是非常丰富，如果想引用方法的参数，前面加上一个 <code>#</code> 即可，既可以引用基本类型的参数，也可以引用对象参数。</p>
<p>缺省对象除了 principal ，还有 authentication</p>
<h2 id="3-使用过滤注解"><a href="#3-使用过滤注解" class="headerlink" title="3.使用过滤注解"></a>3.使用过滤注解</h2><p>Spring Security 中还有两个过滤函数 @PreFilter 和 @PostFilter，可以根据给出的条件，自动移除集合中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostFilter(&quot;filterObject.lastIndexOf(&#x27;2&#x27;)!=-1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        users.add(<span class="string">&quot;javaboy:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PreFilter(filterTarget = &quot;ages&quot;,value = &quot;filterObject%2==0&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllAge</span><span class="params">(List&lt;Integer&gt; ages,List&lt;String&gt; users)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ages = &quot;</span> + ages);</span><br><span class="line">    System.out.println(<span class="string">&quot;users = &quot;</span> + users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 getAllUser 方法中，对集合进行过滤，只返回后缀为 2 的元素，filterObject 表示要过滤的元素对象。</li>
<li>在 getAllAge 方法中，由于有两个集合，因此使用 filterTarget 指定过滤对象。</li>
</ul>
<h2 id="4-动态权限"><a href="#4-动态权限" class="headerlink" title="4.动态权限"></a>4.动态权限</h2><p>动态权限主要通过重写拦截器和决策器来实现</p>
<h1 id="各种类型权限实现原理（ruo-yi）"><a href="#各种类型权限实现原理（ruo-yi）" class="headerlink" title="各种类型权限实现原理（ruo yi）"></a>各种类型权限实现原理（ruo yi）</h1><h3 id="1-菜单权限"><a href="#1-菜单权限" class="headerlink" title="1.菜单权限"></a>1.菜单权限</h3><p>菜单权限很简单，实际上就是简单的用户-角色-菜单模型，那么菜单是什么时候加载的呢？<code>ruoyi-ui\src\permission.js</code>，加载的逻辑在这个文件中。</p>
<p><code>permission.js</code>文件中设置了<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>，每次路由发生变化的时候就会<strong>触发router.beforeEach的回调函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  NProgress.start()</span><br><span class="line">  if (getToken()) &#123;</span><br><span class="line">    /* has token*/</span><br><span class="line">    if (to.path === &#x27;/login&#x27;) &#123;</span><br><span class="line">      next(&#123; path: &#x27;/&#x27; &#125;)</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (store.getters.roles.length === 0) &#123;</span><br><span class="line">        // 判断当前用户是否已拉取完user_info信息</span><br><span class="line">        store.dispatch(&#x27;GetInfo&#x27;).then(res =&gt; &#123;</span><br><span class="line">          // 拉取user_info</span><br><span class="line">          const roles = res.roles</span><br><span class="line">          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;</span><br><span class="line">            // 根据roles权限生成可访问的路由表</span><br><span class="line">            router.addRoutes(accessRoutes) // 动态添加可访问路由表</span><br><span class="line">            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).catch(err =&gt; &#123;</span><br><span class="line">            store.dispatch(&#x27;LogOut&#x27;).then(() =&gt; &#123;</span><br><span class="line">              Message.error(err)</span><br><span class="line">              next(&#123; path: &#x27;/&#x27; &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 没有token</span><br><span class="line">    if (whiteList.indexOf(to.path) !== -1) &#123;</span><br><span class="line">      // 在免登录白名单，直接进入</span><br><span class="line">      next()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`) // 否则全部重定向到登录页</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意`if (store.getters.roles.length === 0) 这段逻辑，可以看出，<strong>如果不刷新当前页面</strong>，就算给用户添加了新的菜单权限，用户也看不到新的菜单。</p>
<h3 id="2-按钮权限"><a href="#2-按钮权限" class="headerlink" title="2.按钮权限"></a>2.按钮权限</h3><p>按钮权限设置上和菜单权限基本上是一样的，是附着于页面中的细粒度权限。按钮权限体现在如果用户没有相应的权限，则看不到相关的按钮。这个是咋实现的呢？</p>
<p>先看下系统管理下的菜单管理中的修改、新增和删除按钮前端vue代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">          &lt;el-button size=&quot;mini&quot; </span><br><span class="line">            type=&quot;text&quot; </span><br><span class="line">            icon=&quot;el-icon-edit&quot; </span><br><span class="line">            @click=&quot;handleUpdate(scope.row)&quot;</span><br><span class="line">            v-hasPermi=&quot;[&#x27;system:menu:edit&#x27;]&quot;</span><br><span class="line">          &gt;修改&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button </span><br><span class="line">            size=&quot;mini&quot; </span><br><span class="line">            type=&quot;text&quot; </span><br><span class="line">            icon=&quot;el-icon-plus&quot; </span><br><span class="line">            @click=&quot;handleAdd(scope.row)&quot;</span><br><span class="line">            v-hasPermi=&quot;[&#x27;system:menu:add&#x27;]&quot;</span><br><span class="line">          &gt;新增&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            icon=&quot;el-icon-delete&quot;</span><br><span class="line">            @click=&quot;handleDelete(scope.row)&quot;</span><br><span class="line">            v-hasPermi=&quot;[&#x27;system:menu:remove&#x27;]&quot;</span><br><span class="line">          &gt;删除&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure>

<p>el-button上有个属性<code>v-hasPermi</code>，这实际上是vue的自定义指令，属性值就是创建按钮的时候定义的那个<code>权限标志</code>。其定义在<code>src/directive/permission/index.js</code>文件</p>
<p>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import hasRole from &#x27;./hasRole&#x27;</span><br><span class="line">import hasPermi from &#x27;./hasPermi&#x27;</span><br><span class="line"></span><br><span class="line">const install = function(Vue) &#123;</span><br><span class="line">  Vue.directive(&#x27;hasRole&#x27;, hasRole)</span><br><span class="line">  Vue.directive(&#x27;hasPermi&#x27;, hasPermi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (window.Vue) &#123;</span><br><span class="line">  window[&#x27;hasRole&#x27;] = hasRole</span><br><span class="line">  window[&#x27;hasPermi&#x27;] = hasPermi</span><br><span class="line">  Vue.use(install); // eslint-disable-line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default install</span><br></pre></td></tr></table></figure>

<p>其具体实现逻辑就在同目录的<code>hasPermi.js</code>文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import store from &#x27;@/store&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  inserted(el, binding, vnode) &#123;</span><br><span class="line">    const &#123; value &#125; = binding</span><br><span class="line">    const all_permission = &quot;*:*:*&quot;;</span><br><span class="line">    const permissions = store.getters &amp;&amp; store.getters.permissions</span><br><span class="line"></span><br><span class="line">    if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">      const permissionFlag = value</span><br><span class="line"></span><br><span class="line">      const hasPermissions = permissions.some(permission =&gt; &#123;</span><br><span class="line">        return all_permission === permission || permissionFlag.includes(permission)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      if (!hasPermissions) &#123;</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new Error(`请设置操作权限标签值`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意代码<code>el.parentNode &amp;&amp; el.parentNode.removeChild(el)</code>，可以看到，如果没有按钮权限，则会将按钮本身从dom中移除。</p>
<h3 id="3-接口权限-可以使用重写拦截器和决策器实现动态接口权限"><a href="#3-接口权限-可以使用重写拦截器和决策器实现动态接口权限" class="headerlink" title="3.接口权限(可以使用重写拦截器和决策器实现动态接口权限)"></a>3.接口权限(可以使用重写拦截器和决策器实现动态接口权限)</h3><p>接口权限和前端的按钮权限一一对应。为的是防止用户绕过按钮直接请求后端接口获取数据。在若依Vue系统中，是使用SpringSecurity的注解<code>@PreAuthorize</code>实现的。</p>
<p>虽然只是一个注解，但是它是SpringSecurity+JWT集成的结晶</p>
<h3 id="4-数据权限"><a href="#4-数据权限" class="headerlink" title="4.数据权限"></a>4.数据权限</h3><p>数据权限实现的关键在于<code>com.ruoyi.framework.aspectj.DataScopeAspect</code>类。该类是一个切面类，凡是加上<code>com.ruoyi.common.annotation.DataScope</code>注解的方法，在执行的时候都会被它拦截。</p>
<p>该切面定义了五种权限范围:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>code</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>DATA_SCOPE_ALL</td>
<td>1</td>
<td>全部数据权限</td>
</tr>
<tr>
<td>DATA_SCOPE_CUSTOM</td>
<td>2</td>
<td>自定数据权限</td>
</tr>
<tr>
<td>DATA_SCOPE_DEPT</td>
<td>3</td>
<td>部门数据权限</td>
</tr>
<tr>
<td>DATA_SCOPE_DEPT_AND_CHILD</td>
<td>4</td>
<td>部门及以下数据权限</td>
</tr>
<tr>
<td>DATA_SCOPE_SELF</td>
<td>5</td>
<td>仅本人数据权限</td>
</tr>
</tbody></table>
<p>该切面的核心逻辑是“拼SQL”，方法执行之前，会给参数的一个params属性添加一个dataScope键值对，key为”dataScope”，值为<code>AND (&quot; + sqlString.substring(4) + &quot;)&quot;</code>样式的一段SQL，这段SQL会根据当前用户所在的部门以及当前用户角色的权限范围发生变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sqlString = new StringBuilder();</span><br><span class="line">        for (SysRole role : user.getRoles())</span><br><span class="line">        &#123;</span><br><span class="line">            String dataScope = role.getDataScope();</span><br><span class="line">            if (DATA_SCOPE_ALL.equals(dataScope))</span><br><span class="line">            &#123;</span><br><span class="line">                sqlString = new StringBuilder();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (DATA_SCOPE_CUSTOM.equals(dataScope))</span><br><span class="line">            &#123;</span><br><span class="line">                sqlString.append(StringUtils.format(</span><br><span class="line">                        &quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = &#123;&#125; ) &quot;, deptAlias,</span><br><span class="line">                        role.getRoleId()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (DATA_SCOPE_DEPT.equals(dataScope))</span><br><span class="line">            &#123;</span><br><span class="line">                sqlString.append(StringUtils.format(&quot; OR &#123;&#125;.dept_id = &#123;&#125; &quot;, deptAlias, user.getDeptId()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope))</span><br><span class="line">            &#123;</span><br><span class="line">                sqlString.append(StringUtils.format(</span><br><span class="line">                        &quot; OR &#123;&#125;.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = &#123;&#125; or find_in_set( &#123;&#125; , ancestors ) )&quot;,</span><br><span class="line">                        deptAlias, user.getDeptId(), user.getDeptId()));</span><br><span class="line">            &#125;</span><br><span class="line">            else if (DATA_SCOPE_SELF.equals(dataScope))</span><br><span class="line">            &#123;</span><br><span class="line">                if (StringUtils.isNotBlank(userAlias))</span><br><span class="line">                &#123;</span><br><span class="line">                    sqlString.append(StringUtils.format(&quot; OR &#123;&#125;.user_id = &#123;&#125; &quot;, userAlias, user.getUserId()));</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    // 数据权限为仅本人且没有userAlias别名不查询任何数据</span><br><span class="line">                    sqlString.append(&quot; OR 1=0 &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，这段代码的逻辑就是用户所在的部门权限越高，数据权限范围越大，查出来的结果集将会越大。</p>
<p>DataScope注解分别加到了部门列表查询、角色列表查询、用户列表查询的接口上，很明显，这几个接口需要根据不同的人查出不同的结果。</p>
<p>以用户列表查询为例，执行sql为</p>
<if test="deptId != null and deptId != 0">         

<p>AND (u.dept_id = #{deptId} OR u.dept_id IN </p>
<p>( SELECT t.dept_id FROM sys_dept t WHERE find_in_set(#{deptId}, ancestors) )</p>
<p>)     </p>
</if>     

<!-- 数据范围过滤 -->     

<p>${params.dataScope}</p>
 </select>

<p>其中，有这么一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 数据范围过滤 --&gt;</span><br><span class="line">$&#123;params.dataScope&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>DataScopeAspect</code>切面就只干了填充params的dataScope属性这么一件事情。</p>
<h2 id="若依Vue系统SpringSecurity-JWT"><a href="#若依Vue系统SpringSecurity-JWT" class="headerlink" title="若依Vue系统SpringSecurity+JWT"></a>若依Vue系统SpringSecurity+JWT</h2><p>若依Vue系统中从用户登录到后端接口权限校验，都是基于SpringSecurity+JWT实现的，其中，SpringSecurity是核心，jwt只是为了保证token合法性的一种手段（签名防止篡改）。spring security集成的相关代码在<code>ruoyi-framework</code>模块的<code>com.ruoyi.framework.security</code>包以及<code>com.ruoyi.framework.config.SecurityConfig</code>类中。</p>
<p><code>SecurityConfig</code>是核心配置类，所有的配置均在该类中。</p>
<h3 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1.用户登录"></a>1.用户登录</h3><p>用户登录的逻辑在方法<code>com.ruoyi.web.controller.system.SysLoginController#login</code>中，一个典型的登录请求体如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;username&quot;: &quot;admin&quot;,</span><br><span class="line">	&quot;password&quot;: &quot;admin123&quot;,</span><br><span class="line">	&quot;code&quot;: &quot;0&quot;,</span><br><span class="line">	&quot;uuid&quot;: &quot;a9fdbcbcb28748b796b5b77ad71bbb97&quot; //uuid由验证码返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>username和password分别是用户名和密码，code为验证码，uuid为验证码的唯一标识。登录成功之后会返回前端一个jwt令牌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;msg&quot;: &quot;操作成功&quot;,</span><br><span class="line">	&quot;code&quot;: 200,</span><br><span class="line">	&quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6IjIzZjRhNjJjLTY5NzMtNDcxZS04ZmU4LWJmYWQ4YzllNWFkMiJ9.9d3iIaNq62CkjTXlxFOQgdDMOAZiu5tAsEn0cEuV23opT6PAqu_CiaN7kQY8_XhlQrHX5RgZ2bH7LpsiKLLcSw&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在登录方法中，做了以下几件事情：</p>
<ul>
<li>根据uuid获取redis中的验证码并对请求的验证码做验证</li>
<li>如果验证码没问题，则对用户名和密码进行校验</li>
<li>如果用户名和密码校验成功，<strong>则使用token作为key将用户信息保存到redis</strong></li>
<li><strong>使用jwt对token签名「将playload（登录信息-密码除外，包含用户的一些信息及过期时间等）和header（包含算法信息）」并返回前端</strong></li>
</ul>
<p>在整个过程中，会抛出一些自定义异常，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">throw new CaptchaExpireException();</span><br><span class="line">throw new CaptchaException();</span><br><span class="line">throw new UserPasswordNotMatchException();</span><br><span class="line">throw new CustomException(e.getMessage());</span><br></pre></td></tr></table></figure>

<p>这些异常最终会被全局异常处理器处理掉：<code>com.ruoyi.framework.web.exception.GlobalExceptionHandler</code></p>
<h3 id="2-接口权限校验"><a href="#2-接口权限校验" class="headerlink" title="2.接口权限校验"></a>2.接口权限校验</h3><p><strong>前端请求完成登录接口之后会将token存储到cookie</strong>，key为Admin-Token，value是jwt令牌。登录逻辑：<code>user.actions.Login</code>。</p>
<p>之后，每次请求后端接口的时候都会带上Authentication Header</p>
<p>这实际上是通过axios的请求拦截器实现的：详情可见<code>src/utils/request.js</code>文件</p>
<p>带着Authentication Header的请求打到后端的时候会经过过滤器<code>com.ruoyi.framework.security.filter.JwtAuthenticationTokenFilter</code>，该过滤器做了以下几件事情</p>
<ul>
<li>从请求头中取出jwt令牌，并对其进行jwt验签（验证签名的有效性），<strong>验签若是成功，则取出原始token</strong></li>
<li><strong>根据token从redis中取出用户数据</strong></li>
<li>将用户信息封装成<code>UsernamePasswordAuthenticationToken</code>对象，并将该对象填充到Spring Security上下文中</li>
</ul>
<p>填充到SpringSecurity上下文才能让Controller接口上的<code>@PreAuthorize</code>注解发挥作用（<strong>存疑，这里若依作者并非使用原生的SpringSecurity提供的spel表达式，也没有用authorities，而是使用了PermissionService类</strong>）。</p>
<p>接着，Controller接口正式执行之前会进入<code>com.ruoyi.framework.web.service.PermissionService#hasPermi</code>方法判定权限，<strong>这里重新从redis中取出用户数据并进行权限校验</strong>，权限校验失败则不再执行接口中逻辑（<strong>存疑，这里并没有使用SpringSecurity上下文中的用户数据，那么<code>JwtAuthenticationTokenFilter</code>中的用户信息填充上下文中的代码是干啥用的</strong>）。</p>
<h4 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h4><p>验证过程：把前端存到header里面的token解析成一个Claims对象获取参数验证（当时间过了设置的token失效时间，这个对象就失效为null，也就未登录）</p>
<p>创建令牌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String token = IdUtils.fastUUID();</span><br><span class="line"></span><br><span class="line">loginUser.setToken(token);</span><br><span class="line">setUserAgent(loginUser);</span><br><span class="line">refreshToken(loginUser);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</span><br><span class="line">claims.put(Constants.LOGIN_USER_KEY, token); //token是IdUtils.fastUUID()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 刷新令牌有效期</span><br><span class="line"> * </span><br><span class="line"> * @param loginUser 登录信息</span><br><span class="line"> */</span><br><span class="line">public void refreshToken(LoginUser loginUser)</span><br><span class="line">&#123;</span><br><span class="line">    loginUser.setLoginTime(System.currentTimeMillis());</span><br><span class="line">    loginUser.setExpireTime(loginUser.getLoginTime() + expireTime * MILLIS_MINUTE);</span><br><span class="line"></span><br><span class="line">    // 根据uuid将loginUser缓存</span><br><span class="line">    String userKey = getTokenKey(loginUser.getToken());</span><br><span class="line">    redisCache.setCacheObject(userKey, loginUser, expireTime, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//验证</span><br><span class="line">LoginUser loginUser = tokenService.getLoginUser(request);//获取token中loginuser</span><br><span class="line">if (StringUtils.isNotNull(loginUser) &amp;&amp; StringUtils.isNull(SecurityUtils.getAuthentication()))</span><br><span class="line">&#123;</span><br><span class="line">    tokenService.verifyToken(loginUser);</span><br><span class="line">    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());</span><br><span class="line">    authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">&#125;</span><br><span class="line">chain.doFilter(request, response);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取请求携带的令牌</span><br><span class="line">String token = getToken(request);</span><br><span class="line">if (StringUtils.isNotEmpty(token))</span><br><span class="line">&#123;</span><br><span class="line">    Claims claims = parseToken(token);</span><br><span class="line">    // 解析对应的权限以及用户信息</span><br><span class="line">    String uuid = (String) claims.get(Constants.LOGIN_USER_KEY);</span><br><span class="line">    String userKey = getTokenKey(uuid);</span><br><span class="line">    LoginUser user = redisCache.getCacheObject(userKey);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完结！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" data-id="ckpfjepzf00000l0t6v6t5cim" data-title="权限设计" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP%EF%BC%8Cjwt/" rel="tag">AOP，jwt</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mq小记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/mq%E5%B0%8F%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T10:17:58.000Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/12/mq%E5%B0%8F%E8%AE%B0/">mq小记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="消息传送可靠性"><a href="#消息传送可靠性" class="headerlink" title="消息传送可靠性"></a>消息传送可靠性</h2><p>1、数据库表：记录发送消息（发送失败时的重试依据）</p>
<p>2、实体类「</p>
<p>msgid；//消息id</p>
<p>Empid;//员工id，可以是多个</p>
<p>status；//状态：成功、失败、投递中</p>
<p><strong>exchange；</strong></p>
<p><strong>routekey；//上述两个为mq要求字段</strong></p>
<p>count；//重试次数</p>
<p>trytime；//重试时间</p>
<p>createtime；//创建时间</p>
<p>updatetime；//更新时间</p>
<p>」</p>
<p>3、场景：添加员工成功后，向该员工发送一条消息</p>
<p>if(result==1){</p>
<p>…</p>
<p>数据库插入一条消息（id为uuid、重试时间（trytime）设置为一分钟后）//后面会设置定时任务，进行重试</p>
<p>…</p>
<p>//Rabbitmqtemplate.convertAndSend(“welcome”,emp);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mailSendLogService.insert(mailSendLog);</span><br><span class="line">rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, new CorrelationData(msgId));</span><br></pre></td></tr></table></figure>

<p>//CorrelationData(msgId)传入唯一标记符</p>
<p>}</p>
<p>4、重新定义rabbitconfig</p>
<p>@Bean</p>
<p>rabbittemplate rabbittemplate（）{</p>
<p>​      new RabbitTEmplate(cachingConnectionFaction);//连接上rabbitmq,消息已经可以发了</p>
<p>​     //需要确认消息有没有发送成功</p>
<p>​     <strong>Rabbittemplate.setConfirmCallBack((data,ack,cause )-&gt;{.   //data：保存了消息的唯一id。ac k:消息是否发送成。</strong></p>
<p>​           If(ack){. //发送成功</p>
<p>​           Data.getid();//消息唯一id</p>
<p>​           sou t（“消息发送成功”）;</p>
<p>​           mailservice.更改数据库消息状态（msgid,status）；</p>
<p>​      }esle{     //失败</p>
<p>​       ……</p>
<p>}</p>
<p>​           <strong>//失败原因:可能是exchange到queue发送失败会有回调</strong></p>
<p>​           <strong>rabbittemplate.setReturnCallback((msg,repcode,reptext,exchange,routingKey)-&gt;{</strong></p>
<p>​        <strong>})</strong></p>
<p>})</p>
<p>};</p>
<p>5、配置queue、exchange、mailbinding</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">Queue mailQueue() &#123;</span><br><span class="line">    return new Queue(MailConstants.MAIL_QUEUE_NAME, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">DirectExchange mailExchange() &#123;</span><br><span class="line">    return new DirectExchange(MailConstants.MAIL_EXCHANGE_NAME, true, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">Binding mailBinding() &#123;</span><br><span class="line">    return BindingBuilder.bind(mailQueue()).to(mailExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、MailConstants定义常用变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MailConstants &#123;</span><br><span class="line">    public static final Integer DELIVERING = 0;//消息投递中</span><br><span class="line">    public static final Integer SUCCESS = 1;//消息投递成功</span><br><span class="line">    public static final Integer FAILURE = 2;//消息投递失败</span><br><span class="line">    public static final Integer MAX_TRY_COUNT = 3;//最大重试次数</span><br><span class="line">    public static final Integer MSG_TIMEOUT = 1;//消息超时时间</span><br><span class="line">    public static final String MAIL_QUEUE_NAME = &quot;javaboy.mail.queue&quot;;</span><br><span class="line">    public static final String MAIL_EXCHANGE_NAME = &quot;javaboy.mail.exchange&quot;;</span><br><span class="line">    public static final String MAIL_ROUTING_KEY_NAME = &quot;javaboy.mail.routing.key&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息投递失败"><a href="#消息投递失败" class="headerlink" title="消息投递失败"></a>消息投递失败</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MailSendTask &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MailSendLogService mailSendLogService;</span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line">    </span><br><span class="line">    //定时任务：每隔十秒跑一次</span><br><span class="line">    @Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span><br><span class="line">    public void mailResendTask() &#123;</span><br><span class="line">        //查询记录表</span><br><span class="line">        List&lt;MailSendLog&gt; logs = mailSendLogService.getMailSendLogsByStatus();//trytime要小于当前时间</span><br><span class="line">        if (logs == null || logs.size() == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历</span><br><span class="line">        logs.forEach(mailSendLog-&gt;&#123;</span><br><span class="line">            if (mailSendLog.getCount() &gt;= 3) &#123;</span><br><span class="line">                mailSendLogService.updateMailSendLogStatus(mailSendLog.getMsgId(), 2);//直接设置该条消息发送失败</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                mailSendLogService.updateCount(mailSendLog.getMsgId(), new Date());</span><br><span class="line">                Employee emp = employeeService.getEmployeeById(mailSendLog.getEmpId());//拿到记录表里员工id对应员工信息，然后重试</span><br><span class="line">                rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, new CorrelationData(mailSendLog.getMsgId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publisher-returns: true</span><br><span class="line">publisher-confirm-type:</span><br></pre></td></tr></table></figure>

<p>//开启confirm和return回调</p>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>1、开启队列接收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch=100</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MailserverApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MailserverApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Queue queue() &#123;</span><br><span class="line">        return new Queue(MailConstants.MAIL_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、@listener</p>
<ul>
<li><p> @RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)</p>
</li>
<li><p>String msgId = (String) headers.get(“spring_returned_message_correlation”);</p>
</li>
<li><p>if (redisTemplate.opsForHash().entries(“mail_log”).containsKey(msgId)) {</p>
<p> //redis 中包含该 key，说明该消息已经被消费过</p>
<pre><code>        logger.info(msgId + &quot;:消息已经被消费&quot;);
        channel.basicAck(tag, false);//确认消息已消费.  
</code></pre>
</li>
</ul>
<p>  ​            return;</p>
<p>  }</p>
<ul>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    @RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)</span><br><span class="line">    public void handler(Message message, Channel channel) throws IOException &#123;</span><br><span class="line">        Employee employee = (Employee) message.getPayload();</span><br><span class="line">        </span><br><span class="line">        MessageHeaders headers = message.getHeaders();</span><br><span class="line">        Long tag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);//消息标记</span><br><span class="line">        String msgId = (String) headers.get(&quot;spring_returned_message_correlation&quot;);//获取唯一标记</span><br><span class="line">        </span><br><span class="line">        if (redisTemplate.opsForHash().entries(&quot;mail_log&quot;).containsKey(msgId)) &#123;</span><br><span class="line">            //redis 中包含该 key，说明该消息已经被消费过</span><br><span class="line">            logger.info(msgId + &quot;:消息已经被消费&quot;);</span><br><span class="line">            channel.basicAck(tag, false);//确认消息已消费</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //收到消息，发送邮件</span><br><span class="line">        MimeMessage msg = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper helper = new MimeMessageHelper(msg);</span><br><span class="line">        try &#123;</span><br><span class="line">            helper.setTo(employee.getEmail());</span><br><span class="line">            helper.setFrom(mailProperties.getUsername());</span><br><span class="line">            helper.setSubject(&quot;入职欢迎&quot;);</span><br><span class="line">            helper.setSentDate(new Date());</span><br><span class="line">            Context context = new Context();</span><br><span class="line">            context.setVariable(&quot;name&quot;, employee.getName());</span><br><span class="line">            context.setVariable(&quot;posName&quot;, employee.getPosition().getName());</span><br><span class="line">            context.setVariable(&quot;joblevelName&quot;, employee.getJobLevel().getName());</span><br><span class="line">            context.setVariable(&quot;departmentName&quot;, employee.getDepartment().getName());</span><br><span class="line">            String mail = templateEngine.process(&quot;mail&quot;, context);</span><br><span class="line">            helper.setText(mail, true);</span><br><span class="line">            javaMailSender.send(msg);</span><br><span class="line">            redisTemplate.opsForHash().put(&quot;mail_log&quot;, msgId, &quot;javaboy&quot;);</span><br><span class="line">            channel.basicAck(tag, false);</span><br><span class="line">            logger.info(msgId + &quot;:邮件发送成功&quot;);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            channel.basicNack(tag, false, true);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;邮件发送失败：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>但是，在这样的机制下，又带来了新的问题，就是消息可能会重复投递，进而导致，消息重复消费，例如一个员工入职了，结果收到了两封入职欢迎邮件，这是不对的。</p>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>幂等性本身是数学上的概念，即使公式：f(x)=f(f(x)) 能够成立的数学性质。在开发领域，则表示对于同一个系统，使用相同的条件，一次请求和多次请求对系统资源的影响是一致的。</p>
<p>在分布式系统中幂等性尤为重要，因为分布式系统中，我们经常会用到接口调用失败进而进行重试这个功能，这样就带来了对一个接口可能会使用相同的条件进行重复调用，在这样的条件下，保证接口的幂等性就尤为重要了。</p>
<p>了解了问题，那么解决方案就很好整了，常见的方案有：</p>
<ul>
<li>MVCC</li>
<li>Token 机制</li>
<li>设计去重表</li>
<li>…</li>
</ul>
<p>MVCC 是多版本并发控制，这种方式就是在数据更新的时候需要去比较所持有的数据版本号，版本号不一致的话，操作会失败，这样每个 version 就只有一次执行成功的机会，一旦失败了必须重新获取。</p>
<p>Token 则是目前使用比较广的一种方式<strong>，核心思想就是每个操作都有一个唯一凭证 token</strong>，一旦执行成功，对于重复的请求，总是返回同一个结果。</p>
<p>这里<strong>RabbitMQ 消费端</strong>实际上就是采用了 Token 这种方式。</p>
<p>大致的思路是这样，<strong>首先将 RabbitMQ 的消息自动确认机制改为手动确认，然后每当有一条消息消费成功了，就把该消息的唯一 ID 记录在 Redis 上</strong>，然后每次收到消息时，都先去 Redis 上查看是否有该消息的 ID，如果有，表示该消息已经消费过了，不再处理，否则再去处理。</p>
<h3 id="如果消息消费失败"><a href="#如果消息消费失败" class="headerlink" title="如果消息消费失败"></a>如果消息消费失败</h3><p>自动退回rabbitmq！！！</p>
<p>比如执行时，抛出异常</p>
<p><img src="https://i.loli.net/2021/06/01/cCkuLtoDrvUbVSZ.png" alt="image-20210601175411320.png"></p>
<p>unacked为1</p>
<p>重试就可能产生多次消费的问题！！！</p>
<p> public void handler(Message message, Channel channel) throws IOException {</p>
<p>}</p>
<p><strong>channel用来手动确认消息是否消费成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long tag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);//消息标记</span><br><span class="line"> String msgId = (String) headers.get(&quot;spring_returned_message_correlation&quot;);//获取唯一标记</span><br></pre></td></tr></table></figure>



<p>邮件发送成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(tag, false);//确认消息已消费，fasle表示丢弃即可</span><br><span class="line"></span><br><span class="line">redisTemplate.opsForHash().put(&quot;mail_log&quot;, msgId, &quot;javaboy&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往Hash中存入数据</span><br><span class="line"> *</span><br><span class="line"> * @param key Redis键</span><br><span class="line"> * @param hKey Hash键</span><br><span class="line"> * @param value 值</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)</span><br><span class="line">&#123;</span><br><span class="line">    redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">&#125;</span><br><span class="line">//取值</span><br><span class="line">opsForHash().entries(&quot;mail_log&quot;).containsKey(msgId)</span><br></pre></td></tr></table></figure>

<p>邮件发送失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicNack(tag, false, true);//true表示回到消息队列</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/mq%E5%B0%8F%E8%AE%B0/" data-id="ckpfj9gk30005cm0tcopi3ayn" data-title="mq小记" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ThreadLocal小结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/ThreadLocal%E5%B0%8F%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T01:57:40.000Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/ThreadLocal%E5%B0%8F%E7%BB%93/">ThreadLocal小结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>数据库连接池中是将connection放进thread！！！</p>
<p>1、threadlocal是为了在并发的情况下，为了保证线程安全，创建了副本</p>
<p>2、确保统一线程之间参数传递的方便</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1、一个用户请求就会启动一个线程。而我们把connection放在ThreadLocal里的话，那么我们的程序只需要一个connection链接数据库就可以了，每个线程都是用的connection的一个副本，那为什么还要用数据库连接池呢？</p>
<p>2、在这种情况下，一个副本里的connection执行了关闭操作，其他都没执行。那么真正与数据库连接的connection什么时候关闭呢？</p>
<p>3、什么时候是从数据库连接池里取connection而什么时候获得的是connection的一个threadlocal副本？</p>
<h4 id="关键："><a href="#关键：" class="headerlink" title="关键："></a>关键：</h4><p>连接池是缓存并托管数据库连接，主要是为了提高性能。</p>
<p>而ThreadLocal缓存连接，<strong>是为了把同一个数据库连接“分享”给同一个线程的不同调用方法</strong>。（不管调用哪个方法，都是使用的同一个连接，方便进行“跨方法”的事务控制）</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>如果一个请求中涉及多个 DAO 操作，而如果这些DAO中的Connection都是独立的话，<strong>就没有办法完成一个事务</strong>。但是如果DAO 中的 Connection 是从 ThreadLocal 中获得的（意味着都是同一个对象）， <strong>那么这些 DAO 就会被纳入到同一个 Connection 之下</strong>。</p>
<h2 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h2><p>连接池里面有一定数量的连接资源，比如最大20个连接。</p>
<p>底层方法一般都是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.DriverManager.getConnection(url, props);</span><br><span class="line"></span><br><span class="line">java.sql.Driver.connect(url, props);</span><br></pre></td></tr></table></figure>

<p>特点是：要传入url、用户名和密码等信息</p>
<p>这种方式，肯定就没有使用数据库连接池。</p>
<p>使用数据库连接池，通<strong>常都是得到一个所谓的javax.sql.DataSource[接口]的实例对象</strong>，它里面<strong>包含了Connection</strong>，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等），肯定是<strong>重新定义了getConnection、closeConnection</strong>等方法</p>
<p><strong>所以你每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接）</strong>，你调用closeConnection方法，也<strong>不是真正的关闭连接</strong>（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>不同的线程在同一个时间（ <strong>或者 同一个线程在多个地方</strong>）从连接池中拿到的Connection，肯定不是同一个连接。</p>
<p>（反过来讲：不同时间的两个线程，一前一后，则有可能拿到同一个连接）</p>
<p>1、假设同一时间多个线程从数据库连接池获取连接，那肯定拿的是不同的连接，我当前线程和别的线程拿的连接不一样，那我当前在crud的时候，不在一个事务之内。</p>
<p>2、假设不同时间的多个线程要从数据库连接池拿连接，那这个时候就可能拿到的是同一个连接了，那我<strong>多个线程线程拿到的是同一个连接！！！</strong></p>
<p>也就是说在多个线程在同一个事务之内，线程a执行了插入还没来得及提交，线程b此时来了个更新，在线程a还未操作完之前，线程b更新完了后，<strong>直接把连接给close了，线程a插了一半发现插不了了！！！！</strong></p>
<p>为了确保不同时间多个线程可能拿到的是同一个连接，那么此时threadlocal闪亮登场，就算我拿的是“同一个连接”，在引入了threadlocal后，<strong>每个线程之间都会创建独立的连接副本，将collection各自copy一份，这样就互相不干扰了（这样线程A的close就不会影响线程B的事务，因为中间还有个连接池管理（close方法已经被重新定义））。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/ThreadLocal%E5%B0%8F%E7%BB%93/" data-id="ckpfj9gjt0000cm0t882kawey" data-title="ThreadLocal小结" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AOP应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/AOP%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T13:47:45.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/AOP%E5%BA%94%E7%94%A8/">AOP应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>简单地去理解，其实AOP要做三类事：</p>
<ul>
<li>在哪里切入，也就是权限校验等非业务操作在哪些业务代码中执行。</li>
<li>在什么时候切入，是业务代码执行前还是执行后。</li>
<li>切入后做什么事，比如做权限校验、日志记录等。</li>
</ul>
<p><img src="https://i.loli.net/2021/05/31/RrDWGu7ksYiHLSV.png" alt="image-20210531211709437.png"></p>
<p>难懂点：</p>
<p>​         织入：就是通过动态代理，在目标对象方法中执行处理内容的过程。</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h3 id="该例的场景是："><a href="#该例的场景是：" class="headerlink" title="该例的场景是："></a>该例的场景是：</h3><ol>
<li>自定义一个注解<code>PermissionsAnnotation</code></li>
<li>创建一个切面类，切点设置为拦截所有标注<code>PermissionsAnnotation</code>的方法，截取到接口的参数，进行简单的权限校验</li>
<li>将<code>PermissionsAnnotation</code>标注在测试接口类的测试接口<code>test</code>上</li>
</ol>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ol>
<li>使用<code>@Target、@Retention、@Documented</code>自定义一个注解：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface PermissionAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建第一个AOP切面类</p>
<p>只要在类上加个 <code>@Aspect</code> 注解即可。</p>
<p>@Aspect<code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。</code></p>
<p>@Component` 注解将该类交给 Spring 来管理。</p>
<p>在这个类里实现第一步权限校验逻辑：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Order(1)</span><br><span class="line">public class PermissionFirstAdvice &#123;</span><br><span class="line"></span><br><span class="line">    // 定义一个切面，😀括号内写入第1步中自定义注解的路径😀</span><br><span class="line">    //@Pointcut 注解，用来定义一个切面，即上文中所关注的某件事情的入口，切入点定义了事件触发时机。</span><br><span class="line">    //另一种写法： @Pointcut(&quot;execution(* com.mutest.controller..*.*(..))&quot;)</span><br><span class="line">    //定义一个切面，拦截 com.itcodai.course09.controller 包和子包下的所有方法</span><br><span class="line">    @Pointcut(&quot;@annotation(com.mu.demo.annotation.PermissionAnnotation)&quot;)</span><br><span class="line">    private void permissionCheck() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //⭐️⭐️⭐️</span><br><span class="line">    //1、@Around可以自由选择增强动作与目标方法的执行顺序，也就是说可以在增强动作前后，甚至过程中执行目标方法。这个特性的实现在于，调用ProceedingJoinPoint参数的procedd()方法才会执行目标方法。</span><br><span class="line">    // 实现@After效果</span><br><span class="line">    // Object rvt = jp.proceed(args);  </span><br><span class="line">    // System.out.println(&quot;执行目标方法之后，模拟结束事务...&quot;);  </span><br><span class="line">    // ......</span><br><span class="line">    //2、@Around可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值。</span><br><span class="line">    </span><br><span class="line">    @Around(&quot;permissionCheck()&quot;)   //上面的permissionCheck()方法</span><br><span class="line">    public Object permissionCheckFirst(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;===================第一个切面===================：&quot; + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        //获取请求参数，详见接口类</span><br><span class="line">        Object[] objects = joinPoint.getArgs();</span><br><span class="line">        Long id = ((JSONObject) objects[0]).getLong(&quot;id&quot;);</span><br><span class="line">        String name = ((JSONObject) objects[0]).getString(&quot;name&quot;);</span><br><span class="line">        System.out.println(&quot;id1-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + id);</span><br><span class="line">        System.out.println(&quot;name1-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + name);</span><br><span class="line"></span><br><span class="line">        // id小于0则抛出非法id的异常</span><br><span class="line">        if (id &lt; 0) &#123;</span><br><span class="line">            return JSON.parseObject(&quot;&#123;\&quot;message\&quot;:\&quot;illegal id\&quot;,\&quot;code\&quot;:403&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return joinPoint.proceed();//还可以传入一个Object[ ]对象，该数组中的值将被传入目标方法作为实参</span><br><span class="line">        </span><br><span class="line">        // 修改入参</span><br><span class="line">        //JSONObject object = new JSONObject();</span><br><span class="line">        //object.put(&quot;id&quot;, 8);</span><br><span class="line">        //object.put(&quot;name&quot;, &quot;lisi&quot;);</span><br><span class="line">        //objects[0] = object;</span><br><span class="line">  </span><br><span class="line">        // 将修改后的参数传入</span><br><span class="line">        //return joinPoint.proceed(objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>创建接口类</p>
<p>并在目标方法上标注自定义注解 <code>PermissionsAnnotation</code>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/permission&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/check&quot;, method = RequestMethod.POST)</span><br><span class="line">    // 添加这个注解</span><br><span class="line">    @PermissionsAnnotation()</span><br><span class="line">    public JSONObject getGroupList(@RequestBody JSONObject request) &#123;</span><br><span class="line">        return JSON.parseObject(&quot;&#123;\&quot;message\&quot;:\&quot;SUCCESS\&quot;,\&quot;code\&quot;:200&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>1、@Before</p>
<p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 <code>Log</code> 处理，也可以做一些信息的统计，比如获取用户的请求 <code>URL</code> 以及用户的 <code>IP</code> 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。</p>
<p>2、@After</p>
<p><code>@After</code> 注解和 <code>@Before</code> 注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 Log 处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/AOP%E5%BA%94%E7%94%A8/" data-id="ckpfj9gk20004cm0tbng33hed" data-title="AOP应用" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-关于虚拟机中的垃圾回收" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/05/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-05T08:20:06.000Z" itemprop="datePublished">2021-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/05/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">关于虚拟机中的垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-虚拟机可以给不同代使用不同的回收算法"><a href="#Java-虚拟机可以给不同代使用不同的回收算法" class="headerlink" title="Java 虚拟机可以给不同代使用不同的回收算法"></a>Java 虚拟机可以给不同代使用不同的回收算法</h1><h2 id="对于新生代"><a href="#对于新生代" class="headerlink" title="对于新生代"></a>对于新生代</h2><p>猜测大部分的Java对象只存活一小段时间，便可以采用耗时比较短的垃圾回收算法，让大部分的垃圾在新生代被回收掉。</p>
<h3 id="主要针对新生代的Minor-GC"><a href="#主要针对新生代的Minor-GC" class="headerlink" title="主要针对新生代的Minor GC"></a>主要针对新生代的Minor GC</h3><h4 id="1、-堆-的划分"><a href="#1、-堆-的划分" class="headerlink" title="1、==堆==的划分"></a>1、==堆==的划分</h4><p>Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p>
<p><img src="https://i.loli.net/2021/05/31/9bZkxIRrdp1m6Pt.png" alt="截屏2021-05-31 下午4.27.10.png"></p>
<p>当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。==由于堆空间是线程共享的==，因此直接在这里边划空间是需要进行同步的（否则，将有可能出现两个对象共用一段内存的事故）。</p>
<h5 id="当-Eden-区的空间耗尽了怎么办？"><a href="#当-Eden-区的空间耗尽了怎么办？" class="headerlink" title="当 Eden 区的空间耗尽了怎么办？"></a>当 Eden 区的空间耗尽了怎么办？</h5><p>这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。</p>
<p>新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。</p>
<h5 id="当发生-Minor-GC-时！！！"><a href="#当发生-Minor-GC-时！！！" class="headerlink" title="当发生 Minor GC 时！！！"></a>当发生 Minor GC 时！！！</h5><p>Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后==交换 from 和 to 指针==，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p>
<h5 id="何时晋升老年代？"><a href="#何时晋升老年代？" class="headerlink" title="何时晋升老年代？"></a>何时晋升老年代？</h5><p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p>
<p>总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法（理想情况下，Eden 区中的对象基本都死亡了，那么==需要复制的数据将非常少==，因此采用这种标记 - 复制算法的效果极好），将 Survivor 区中的老存活对象晋升到老年代，然后将==剩下的存活对象====和 Eden 区的存活对象==复制到==另一个 Survivor 区（to）==中。</p>
<h5 id="什么是标记复制算法？"><a href="#什么是标记复制算法？" class="headerlink" title="什么是标记复制算法？"></a>什么是标记复制算法？</h5><p>优点：解决了内存碎片问题。</p>
<p>缺点：将原来的内存缩小为原来的一半，存活对象越多效率越低。</p>
<p><img src="https://i.loli.net/2021/05/31/ASNhKnjFz5W2PdD.png" alt="image-20210531164734367.png"></p>
<h5 id="Minor-GC-的另外一个好处是不用对整个堆进行垃圾回收。"><a href="#Minor-GC-的另外一个好处是不用对整个堆进行垃圾回收。" class="headerlink" title="Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。"></a>Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。</h5><p>但是，它却有一个问题，==那就是老年代的对象可能引用新生代的对象==。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。</p>
<h5 id="这样一来，岂不是又做了一次全堆扫描呢？"><a href="#这样一来，岂不是又做了一次全堆扫描呢？" class="headerlink" title="这样一来，岂不是又做了一次全堆扫描呢？"></a>这样一来，岂不是又做了一次全堆扫描呢？</h5><p>HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。</p>
<p>该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。==这个标识位代表对应的卡是否可能存有指向新生代对象的引用。==如果可能存在，那么我们就认为这张卡是脏的。</p>
<p>在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是==在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里==。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。</p>
<h2 id="对于老年代"><a href="#对于老年代" class="headerlink" title="对于老年代"></a>对于老年代</h2><p>猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。</p>
<p><strong>这时候</strong>，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/05/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" data-id="ckpfj9gk30006cm0t414s9lcv" data-title="关于虚拟机中的垃圾回收" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/04/Redis/index/" class="article-date">
  <time class="dt-published" datetime="2021-05-04T04:57:40.000Z" itemprop="datePublished">2021-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/04/Redis/index/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>hashMap的插入</p>
<p>1、判空，为空初始化</p>
<p>2、不为空，计算key的hash值，存放数组对应下标index（（n-1）%hash）</p>
<p>3、<strong>查看table[index]是否存在数据</strong>，没有数据就构造一个Node节点放在table[index]</p>
<p>4、存在，说明发生了<strong>hash冲突</strong>，继续判断key是否相等，相等则更新value</p>
<p>5、<strong>如果不相等，判断是否树形节点</strong>，如果是树形节点，创建树形接待你插入红黑树中</p>
<p>6、如果不是树形节点，创建普通Node加入链表中；并判断；<strong>链表长度是否大于8</strong>，大于的话链表转化为红黑树</p>
<p>7、<strong>插入完成后判断当前节点数是否大于阈值</strong>，如果大于开始扩容为原数组的二倍</p>
<p>hashMap初始化</p>
<p>一般如果<code>new HashMap()</code> 不传值，默认大小是 16，负载因子是 0.75， 如果自己<strong>传入初始大小 k，初始化大小为大于 k 的 2 的整数次方</strong>，例如如果传 10，大小为 16（传入k=50，大小为2的6次方）。</p>
<p>算法就是让初始二进制分别右移 1，2，4，8，16位，与自己异或，把高位第一个为 1 的数通过不断右移，把高位为 1 的后面全变为 1，111111 + 1 = 1000000  = 2的6次方（符合大于 50 并且是 2 的整数次幂 ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123; </span><br><span class="line">int n = cap - 1;  </span><br><span class="line">n |= n &gt;&gt;&gt; 1; </span><br><span class="line">n |= n &gt;&gt;&gt; 2; </span><br><span class="line">n |= n &gt;&gt;&gt; 4; </span><br><span class="line">n |= n &gt;&gt;&gt; 8;  </span><br><span class="line">n |= n &gt;&gt;&gt; 16; </span><br><span class="line">return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ?    MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hash函数的设计</p>
<p> hash 函数是先拿到<strong>通过 key  的 hashcode，是 32 位的 int 值，然后让 hashcode 的高 16 位和低 16 位进行异或操作。</strong></p>
<p>这个也叫扰动函数，这么设计有二点原因：</p>
<p>1、一定要尽可能降低 hash 碰撞，越分散越好；</p>
<p>key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 <strong>-2147483648~2147483647</strong>，前后加起来大概 40 亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 -1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是 00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10100101 11000100 00100101</span><br><span class="line">&amp; 00000000 00000000 00001111</span><br><span class="line">----------------------------------  </span><br><span class="line">00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。<strong>而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</strong></p>
<p>2、算法一定要尽可能高效，因为这是高频操作, 因此采用位运算。</p>
<p>源码中模运算就是把散列值和数组长度 -1 做一个”与”操作，位运算比 % 运算要快。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line">static int indexFor(int h, int length) &#123;     </span><br><span class="line">return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>hashmap 1.8的优化</p>
<p>1、<strong>数组+链表改成了数组+链表或红黑树</strong>；</p>
<p>防止发生 hash 冲突，链表长度过长，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code>；</p>
<p>2、链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，<strong>1.8 遍历链表，将元素放置到链表的最后；</strong></p>
<p>​       A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环</p>
<p><img src="https://i.loli.net/2021/05/31/Z2y7aOv4GIJBXMH.png" alt="上传1.png"></p>
<p>3、扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，<strong>1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小；</strong></p>
<p>  这是由于扩容是扩大为原数组大小的 2 倍，用于计算数组位置的掩码仅仅只   </p>
<p>  是高位多了一个 1，举个例子：</p>
<p>  扩容前长度为 16，用于计算 <strong>(n-1) &amp; hash</strong> 的二进制 n - 1 为 0000 1111， </p>
<p>   <strong>扩容后为 32 后的二进制就高位多了 1，============&gt;为 0001 1111。</strong></p>
<p><strong>因为是 &amp; 运算</strong>，<strong>1 和任何数 &amp; 都是它本身</strong>，那就分二种情况，如下图：原数据 hashcode 高位第 4 位为 0 和高位为 1 的情况；</p>
<p>第四位高位为 0，重新 hash 数值不变，第四位为 1，重新 hash 数值比原来大 16（旧数组的容量）。</p>
<p><img src="https://i.loli.net/2021/05/31/GSOu5roHPDx6zp9.png" alt="上传2.png"></p>
<p>4、在插入时，1.7 先判断是否需要扩容，再插入，<strong>1.8 先进行插入，插入完成再判断是否需要扩容。</strong></p>
<p><strong>HashMap 是线程安全的吗？</strong></p>
<p>不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有<strong>数据覆盖、多线程同时扩容</strong>的问题。</p>
<p><strong>那你平常怎么解决这个线程不安全的问题？</strong></p>
<p>Java 中有 <strong>HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap</strong> 可以实现线程安全的 Map。</p>
<ol>
<li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大；</li>
<li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li>
<li>ConcurrentHashMap 使用分段锁，降低了锁粒度，让并发度大大提高。</li>
</ol>
<p> <strong>ConcurrentHashMap 的分段锁的实现原理吗？</strong></p>
<p>ConcurrentHashMap </p>
<p>1、成员变量使用 volatile 修饰，免除了指令重排序，同时保证内存可见性</p>
<p>2、另外使用 CAS 操作和 synchronized 结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p>
<p><strong>你前面提到链表转红黑树是链表长度达到阈值，这个阈值是多少？</strong> </p>
<p>阈值是 8，红黑树转链表阈值为 6。</p>
<p><strong>为什么是 8，不是 16，32 甚至是 7 ？又为什么红黑树转链表的阈值是 6，不是 8 了呢？</strong></p>
<p>因为经过计算，在 hash 函数设计合理的情况下，<strong>发生 hash 碰撞 8 次的几率为百万分之 6</strong>，概率说话。。因为 8 够用了，至于为什么转回来是 6，<strong>因为如果 hash 碰撞次数在 8 附近徘徊，会一直发生链表和红黑树的转化，为了预防这种情况的发生。</strong></p>
<p>1、 HashMap 内部节点是有序的吗？</p>
<p><strong>是无序的，根据 hash 值随机插入。</strong></p>
<p>2、那有没有有序的 Map？</p>
<p><strong>LinkedHashMap 和 TreeMap。</strong></p>
<p>3、 跟我讲讲 LinkedHashMap 怎么实现有序的？</p>
<p><strong>LinkedHashMap 内部维护了一个单链表</strong>，有 头尾节点 ，</p>
<p>同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，</p>
<p>还<strong>有 before  和 after 用于标识前置节点和后置节点。</strong>可以实现按插入的顺序或访问顺序排序。</p>
<p>4、跟我讲讲 TreeMap 怎么实现有序的？</p>
<p>TreeMap 是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，<strong>内部是通过红黑树来实现</strong>。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用户 key 的比较。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/04/Redis/index/" data-id="ckpfj9gk5000acm0t2tl0bz0r" data-title="HashMap" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hashmap/" rel="tag">hashmap</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MYSQL事务小记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/01/MYSQL%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-01T03:29:09.000Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/01/MYSQL%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/">MYSQL事务小记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><p><strong>事务概念</strong>：提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。<br>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。（要么全部成功，要么全部失败）</p>
<p><strong>事务支持是在引擎层实现的</strong>：MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p>
<h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>ACID（Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性）</p>
<h3 id="I（Isolation隔离性）"><a href="#I（Isolation隔离性）" class="headerlink" title="I（Isolation隔离性）"></a>I（Isolation<strong>隔离性</strong>）</h3><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读到其他事务<strong>未提交的数据</strong></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>前后读取的<strong>记录内容</strong>不一致</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>前后读取的<strong>记录数量</strong>不一致</p>
<h3 id="–-gt-隔离级别"><a href="#–-gt-隔离级别" class="headerlink" title="–&gt;隔离级别"></a>–&gt;隔离级别</h3><ul>
<li><p>隔离越严实，效率越低</p>
</li>
<li><p>sql标准的事务隔离级别包括：</p>
<p>1、读未提交   </p>
<p>一个事务还没提交时，它做的变更就能被别的事务看到</p>
<p>2、读提交  </p>
<p>一个事务提交之后，它做的变更才会被其他事务看到</p>
<p>3、可重复读 （别人改数据的事务已经提交，我在我的事务中也不去读）</p>
<p>一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的）。当然在可重读读隔离级别下，未提交变更对其他事务也是不可见的</p>
<p>场景：假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果（这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。）</p>
<p>4、串行化</p>
</li>
</ul>
<p>​       顾名思义，对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等钱一个事务执行完成，才能继续执行</p>
<h3 id="–-gt-事务隔离级别的实现"><a href="#–-gt-事务隔离级别的实现" class="headerlink" title="–&gt;事务隔离级别的实现"></a>–&gt;事务隔离级别的实现</h3><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://i.loli.net/2021/05/31/FDNJ5qOeC8ZpjMo.png" alt="image-20210419105450131.png"></p>
<p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。<strong>对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</strong></p>
<p>同时你会发现，<strong>即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</strong></p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除（<strong>当没有比回滚日志更早的读视图（读视图在事务开启时创建）的时候，这个数据不会再有谁驱使它回滚了，这个回滚日志也就失去了用武之地，可以删除了</strong>）</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<h3 id="为什么尽量不要使用长事务？"><a href="#为什么尽量不要使用长事务？" class="headerlink" title="为什么尽量不要使用长事务？"></a>为什么尽量不要使用长事务？</h3><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/01/MYSQL%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/" data-id="ckpfj9gjy0001cm0tf0i7ggth" data-title="MYSQL事务小记" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%83%E9%99%90/">权限</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/">线程的实现</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP%EF%BC%8Cjwt/" rel="tag">AOP，jwt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashmap/" rel="tag">hashmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/votile/" rel="tag">votile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/AOP%EF%BC%8Cjwt/" style="font-size: 10px;">AOP，jwt</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">Java虚拟机</a> <a href="/tags/hashmap/" style="font-size: 20px;">hashmap</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/rabbitmq/" style="font-size: 10px;">rabbitmq</a> <a href="/tags/votile/" style="font-size: 10px;">votile</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 20px;">多线程</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/02/url%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/">url输入到返回请求的过程</a>
          </li>
        
          <li>
            <a href="/2021/06/02/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D/">实现线程的方式只有一种</a>
          </li>
        
          <li>
            <a href="/2021/06/02/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
          </li>
        
          <li>
            <a href="/2021/05/20/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">权限设计</a>
          </li>
        
          <li>
            <a href="/2021/05/12/mq%E5%B0%8F%E8%AE%B0/">mq小记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 PP<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">专栏</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
package org.javaboy.vhr.util.设计模式.装饰器模式;

/**
 * TODO 核心：是在不改变原有类的基础上给类新增功能。
 * 对于不改变原有类，可能有的人回想到继承、AOP切面
 * 但是使用装饰器模式是另外一种更灵活的思路，能够避免继承导致的子类过多问题，也可以避免AOP带来的复杂性问题
 *
 * 例如：new BufferedReader（new FileReader（" "））
 * java开发字节流、字符流和文件流
 * 一层嵌套一层，字节流转字符流等，这就是使用装饰器模式的一种体现
 *
 * @author xyf
 * @version 1.0
 * @date 2021/5/19 3:11 下午
 */
public class 装饰器模式 {

    //场景：单点登录权限功能扩充

    //ERP系统（登录账户验证即可）--》专门的运营、营销、数据人员 --》突通的权限

    //装饰器模式：扩充原有的单点登录服务，同时也保证原油功能不受破坏，可以继续使用

    //解决：直接继承时因功能的不断横向扩展导致子类膨胀问题，而使用装饰器模式比直接继承更加灵活，同时也不要维护子类

    //重要的四点：
    //1、抽象构件角色（component）：定义抽象接口；
    //2、具体构件角色（ConcreteComponent）：实现抽象接口，可以是一组；
    //3、装饰角色（Decorator）：定义抽象类并继承接口中的方法，保证一致性
    //4、具体装饰角色（ConcreteDecorator）：扩展装饰具体的实现逻辑

    //另一种场景也可以使用装饰器
    //之前实现某个接口接收单个消息，但由于外部升级 --》变为发送list集合消息
    //但又不希望所有的代码都修改这部分逻辑，就可以使用装饰器模式进行适配list集合
    //给使用者的依然是for循环后的单个消息

}
